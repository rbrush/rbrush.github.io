---           
layout: post
title: Rules as Data
date: 2014-01-19 18:44:40 UTC
updated: 2014-01-19 18:44:40 UTC
comments: false
categories: 
---
This started as a topic for a&nbsp;<a href="http://www.meetup.com/lamba-lounge-kc/" target="_blank">Lambda Lounge</a>&nbsp;meetup but seems worth sharing broadly.<br />I've posted previously about treating <a href="http://www.toomuchcode.org/2013/09/rules-as-control-structure.html" target="_blank">rules as a control structure</a>, but for <a href="https://github.com/rbrush/clara-rules" target="_blank">Clara 0.4</a> rules are now first-class data structures with well-defined schema. &nbsp;The simple <i>defrule</i>&nbsp;syntax is preserved but the macro now produces a data structure that is used everywhere else. For example, the following code:<br />

``` clojure
(defrule date-too-early 
  "We can't schedule something too early."
  [WorkOrder (< (weeks-until date) 2)]  
  =>  
  (insert! (->ApprovalRequired :timeline "Date is too early")))
```

Defines a var containing this structure:<br /><br />
``` clojure
{:doc "We can't schedule something too early.",
 :name "date-too-early",
 :lhs
 [{:constraints [(< (llkc.example/weeks-until date) 2)],
   :type llkc.example.WorkOrder}],
 :rhs
 (clara.rules/insert!
  (llkc.example/->ApprovalRequired :timeline "Date is too early"))}
```
<br />

The rule structure itself is <a href="https://github.com/rbrush/clara-rules/blob/master/src/main/clojure/clara/rules/schema.clj#L50" target="_blank">defined in Clara's schema</a>, and simply stored in the var with the rule's name.<br /><br />So, now that rules are data, we open the door to tooling to explore and manipulate them. For instance, we can visualize the relationship between rules. Here is a visualization of the <a href="https://github.com/rbrush/presentations/blob/master/llkc-2014-jan/src/llkc/example.clj" target="_blank">rules used for the meetup</a>. I arbitrarily chose shapes to distinguish the different types of data:<br /><div class="separator" style="clear: both; text-align: center;"><br /></div><div class="separator" style="clear: both; text-align: center;"><a href="/images/rules-as-data-logic.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="/images/rules-as-data-logic-small.png" /></a></div><br /><br />This image is generated by running the following <a href="https://github.com/rbrush/clara-rules/blob/master/src/main/clojure/clara/tools/viz.clj" target="_blank">function from clara.tools.viz</a> against <a href="https://github.com/rbrush/presentations/blob/master/llkc-2014-jan/src/llkc/example.clj" target="_blank">the example used at the meetup</a>:<br />

``` clojure
(viz/show-logic! 'llkc.example)
```
<br />

That function simply scans each rule in the given namespace, reads individual conditions from the rule data structure, and wires them up. The graph itself is rendered with GraphViz.<br /><br />Since all rules of data, they can be filtered or manipulated like any Clojure data structure. So here we take our set of rules and only display those that handle logic for validation errors:<br />

``` clojure
(viz/show-logic!
  (filter #(viz/inserts? % ValidationError)
    (viz/get-productions ['llkc.example])))
```
<br />

In this example there is only one rule that does validation, so the resulting image looks like this:<br /><div class="separator" style="clear: both; text-align: center;"><a href="/images/rules-as-data-valid.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="/images/rules-as-data-valid.png" height="169" width="320" /></a></div><br /><h2>Rule engine as an API</h2>The rules-as-data model creates another significant advantage: we have decoupled the DSL-style syntax from the rule engine itself. Clara users can now create rules from arbitrary sources, such as a specialized syntax, an external database, or domain-specific file format. (Think <a href="https://github.com/Engelberg/instaparse" target="_blank">instaparse</a> tied to rule generation.) Clara is evolving into a general Rete engine, with its "defrule" syntax being just one way to use it.<br /><br />So far I've written only simple, GraphViz-based visualizations but we can expose these with more sophisticated UIs. Projecting such visualizations onto, say, a D3-based graph could provide a rich, interactive way of exploring logic.<br /><br />At this point, <a href="https://github.com/rbrush/clara-rules" target="_blank">Clara 0.4 is available as snapshot builds</a>. I expect to do a release in February, pending some cleanup and enhancements to ClojureScript support. I'll post updates on my twitter feed, <a href="https://twitter.com/ryanbrush" target="_blank">@ryanbrush</a>.