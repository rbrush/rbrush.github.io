---           
layout: post
title: Tearing Down the Software Factory
date: 2008-03-09 20:25:44 UTC
updated: 2008-03-09 20:25:44 UTC
comments: false
categories: 
---
 
Tom DeMarco <a title="said it well" href="http://www.amazon.com/Measuring-Managing-Performance-Organizations-Robert/dp/0932633366" id="wp1z">said it well</a>:<br /><blockquote>The idea of a software factory is a joke -- that we can build software by rote -- that's ridiculous.  If the work is deterministic, we will do with it what we do with any other big piece of deterministic work.  We'll let the computer do the deterministic portion, leaving the person who interacts with the computer -- the other half of the system -- to do the work whose roteness has decreased, not increased.  Every time you automate something, what's left of the person's work is less deterministic, until eventually, when you automate enough, there's no deterministic element left for the person's work--no rote. ... Our work is not deterministic.  It's far too inventive.  We're knowledge workers, not factory workers.<br /></blockquote>Of course, similar thoughts have been articulated <a title="many" href="http://www.developerdotstar.com/mag/articles/reeves_design_main.html" id="j1bs">many</a> <a title="times" href="http://virtualschool.edu/mon/SoftwareEngineering/BrooksNoSilverBullet.html" id="s7.0">times</a> before, and was a theme of the <a title="previous post" href="http://www.toomuchcode.org/2007/10/design-crisis.html" id="oihe">previous post</a> on this blog.  The idea of a software factory contradicts our best understanding of the essence of software, yet industrial style command-and-control management of software continues.  Why is this?  One problem is we developers haven't effectively presented a convincing alternative.  Remove command and control, and to some extent developers must manage themselves.  From <a title="Watts Humphrey" href="http://www.sei.cmu.edu/news-at-sei/columns/watts_new/2007/06/watts-new-2007-06.htm" id="hcuj">Watts Humphrey</a>:<br /><blockquote>Since your managerâ€™s performance depends on your performance, and since the performance of software groups has historically been so poor, managers do not trust software professionals to manage themselves. To overcome this problem, all we have to do is to convince management that we can manage ourselves and then perform that self management so well that management will continue to trust us.<br /></blockquote>The theme of trust and credibility runs throughout Humphrey's <a title="written extensively" href="http://www.sei.cmu.edu/news-at-sei/columns/watts_new/watts-new.htm" id="hbo3">extensive writing</a> on this topic.  This is not new, but progress has been slow.  The major obstacle is that managers rightly want concrete, objective data on which to base their decisions.  This conflicts with the black box that software development so often becomes.  We need better transparency.  It is time to open up the black box of software engineering.<br /><br /><b>The black box of software</b><br />Opening the black box means programmers and managers must meet each other halfway.  Managers must create and adapt to a new post-industrial management science, and programmers must produce data useful to that management science.   This does not mean attempting to make programmers into assembly line workers.  To the contrary, it means embracing the creative nature of software, and managing the output as a side effect of development.<br /><br />How do we do this?  Empirically manage everything that can be empirically managed, and complement it with the judgment of your best engineers.  Many pieces of the puzzle already exist.  <a title="Unit testing" href="http://en.wikipedia.org/wiki/Unit_testing" id="lze7">Unit testing</a>, <a title="code coverage reports" href="http://en.wikipedia.org/wiki/Code_coverage" id="rqf8">code coverage reports</a>, <a title="bug tracking" href="http://en.wikipedia.org/wiki/Bug_tracking_system" id="gezm">bug tracking</a>, <a title="static code analysis" href="http://en.wikipedia.org/wiki/Static_code_analysis" id="z03-">static code analysis</a>, dependency management and others provide transparency into the state of a project.  Such data is purely informational, but technically inclined managers can and should use it to ensure a project is on track.  With context, problems like bloated dependencies, poor test coverage, or fixing related bugs many times are all signs of a project going astray.  Modern software organizations must be able to detect and correct problems before they grow.<br /><br />Unfortunately many managers today are not equipped to work with such data.  This must change.  Managers must build their skill sets for the post-industrial world.<br /><br /><b>Trust through transparency<br /></b>Of course tools like code coverage and defect tracking only tell part of the story.  <a title="Code is design" href="http://www.toomuchcode.org/2007/10/design-crisis.html" id="f.tg">Code is design</a>, and no set of tools can define the quality or progress of design.  Therefore we must complement these tools with the best judgment of our best engineers.  But if managers don't trust the best engineers, this judgment is wasted.<br /><br />So how do we solve this?  Use transparency into software as a tool for building trust.   Concrete data on the progress and quality of software gives managers greater confidence in engineers, even if the picture is incomplete.  Trust begins to grow.  Engineers should qualify empirical data and use it appropriately as a basis for design decisions.   If we can provide managers a glimpse into software and prove we are making progress, they will be more willing to accept our opinions.<br /><br />Some tension between managers and developers may be inevitable, but we can meet each other halfway.  Our development practices should yield hard data for everything appropriate.  In exchange managers must accept that code is design and trust the judgment of developers.