
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Too Much Code</title>
  <meta name="author" content="Ryan Brush">

  
  <meta name="description" content="It&#8217;s finally being accepted: the shared memory, critical region model for concurrent programming is broken. Even good programmers slip up and &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://www.toomuchcode.org/blog/page/3">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="Too Much Code" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=Open+Sans" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=Fjalla+One" rel="stylesheet" type="text/css">
<!--- MathJax Configuration -->
<script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-2927953-1', 'auto');
    ga('send', 'pageview');

  </script>



</head>

<body   class="collapse-sidebar sidebar-footer" >
  <header role="banner"><hgroup>
  <h1><a href="/">Too Much Code</a></h1>
  
    <h2>Not enough cohesion</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscribe" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS" target="_blank"><svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="25" height="25" viewbox="0 0 100 100"><path class="social" d="M 13.310204,73.332654 C 5.967347,73.332654 0,79.322448 0,86.621428 c 0,7.338776 5.967347,13.262246 13.310204,13.262246 7.370408,0 13.328572,-5.92245 13.328572,-13.262246 0,-7.29898 -5.958164,-13.288774 -13.328572,-13.288774 z M 0.01530612,33.978572 V 53.143878 C 12.493878,53.143878 24.229592,58.02347 33.068368,66.865306 41.894898,75.685714 46.767346,87.47449 46.767346,100 h 19.25 C 66.017346,63.592858 36.4,33.979592 0.01530612,33.978572 l 0,0 z M 0.03877552,0 V 19.17449 C 44.54796,19.17551 80.77551,55.437756 80.77551,100 H 100 C 100,44.87653 55.15102,0 0.03877552,0 z"></path></svg></a></li>
  
</ul>
  
  
  
  
  
<ul class="subscribe">
  <li><a href="https://github.com/rbrush" rel="subscribe-github" title="@rbrush on GitHub" target="_blank"><svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="25" height="25" viewbox="0 0 100 100"><path class="social" d="M 50,0 C 22.385714,0 0,22.385714 0,50 0,77.614286 22.385714,100 50,100 77.614286,100 100,77.614286 100,50 100,22.385714 77.614286,0 50,0 z m 29.692858,79.692858 c -3.859184,3.859182 -8.351022,6.887754 -13.35,9.00306 -1.27041,0.536736 -2.560204,1.009184 -3.867348,1.415306 v -7.493878 c 0,-3.938774 -1.35102,-6.835714 -4.053062,-8.690816 1.692858,-0.163264 3.24694,-0.390816 4.663266,-0.683672 1.416326,-0.292858 2.913266,-0.716328 4.491838,-1.27041 1.57857,-0.55408 2.994896,-1.213264 4.247958,-1.97755 1.253062,-0.765306 2.458164,-1.758164 3.613266,-2.978572 1.155102,-1.220408 2.12449,-2.604082 2.905102,-4.15 0.780612,-1.545918 1.4,-3.40204 1.855102,-5.566326 0.455102,-2.164286 0.683674,-4.54898 0.683674,-7.153062 0,-5.045918 -1.643878,-9.341836 -4.931634,-12.890816 C 77.44796,33.35 77.285714,29.10204 75.463266,24.512244 l -1.22143,-0.145918 c -0.845918,-0.09796 -2.368366,0.260204 -4.565306,1.07449 -2.196938,0.814286 -4.663264,2.14796 -7.396938,4.004082 -3.87449,-1.07449 -7.893878,-1.611224 -12.061224,-1.611224 -4.19898,0 -8.203062,0.536734 -12.012246,1.611224 -1.72449,-1.17245 -3.361224,-2.139796 -4.907142,-2.905102 C 31.753062,25.77449 30.516326,25.254082 29.587756,24.97653 28.660204,24.7 27.79796,24.528572 27,24.463266 c -0.79796,-0.0653 -1.310204,-0.08062 -1.537756,-0.04898 -0.22755,0.03164 -0.390816,0.0653 -0.487754,0.09796 -1.82347,4.62245 -1.985714,8.87143 -0.487756,12.743878 -3.287754,3.54796 -4.931632,7.844898 -4.931632,12.890816 0,2.604082 0.227552,4.988776 0.683674,7.153062 0.456122,2.164286 1.07449,4.020408 1.855102,5.566326 0.780612,1.545918 1.75,2.929592 2.905102,4.15 1.155102,1.220408 2.360204,2.213266 3.613264,2.978572 1.253062,0.766326 2.669388,1.42449 4.24796,1.97755 1.578572,0.554082 3.07551,0.976532 4.491836,1.27041 1.416328,0.292856 2.970408,0.521428 4.663266,0.683672 -2.669388,1.82347 -4.004082,4.720408 -4.004082,8.690816 v 7.639796 C 36.536734,89.818368 35.083674,89.3 33.656122,88.695918 c -4.99898,-2.115306 -9.490816,-5.143878 -13.35,-9.00306 -3.859184,-3.859184 -6.887754,-8.351022 -9.00306,-13.35 C 9.1163263,61.171428 8.0071428,55.67347 8.0071428,50 c 0,-5.67347 1.1091835,-11.171428 3.2969392,-16.342858 2.115306,-4.998978 5.143878,-9.490816 9.00306,-13.35 3.859184,-3.859182 8.351022,-6.887754 13.35,-9.00306 C 38.828572,9.1163266 44.32653,8.0071428 50,8.0071428 c 5.67347,0 11.171428,1.1091838 16.342858,3.2969392 5,2.115306 9.490816,5.143878 13.35,9.00306 3.859182,3.859184 6.887754,8.351022 9.00306,13.35 2.186736,5.17245 3.295918,10.67041 3.295918,16.342858 0,5.672448 -1.109182,11.171428 -3.296938,16.342858 -2.115306,4.998978 -5.143878,9.490816 -9.00204,13.35 l 0,0 z"></path></svg></a></li>
</ul>
  
  
  
<ul class="subscribe">
  <li><a href="https://twitter.com/ryanbrush" rel="subscribe-twitter" title="@ryanbrush on Twitter" target="_blank"><svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="25" height="25" viewBox="0 0 512 512"><path class="social" d="M0.001,334.932c33.327,30.816,118.891,59.981,188.517-8.271c-12.52,1.955-22.972-0.416-30.913-8.269
  c-7.531-7.465-7.945-15.182-3.914-22.202c3.275-5.725,10.184-9.741,16.977-13.934c-12.323,2.285-22.829,1.095-32.218-3.706
  c-12.604-6.444-24.863-13.228-28.3-27.207c7.71-8.112,16.28-15.359,34.831-12.627c-17.45-5.83-33.087-13.429-44.41-24.815
  c-11.028-11.091-12.163-18.302-13.932-26.996c9.632-3.567,19.688-5.421,30.478-4.353c-24.397-12.476-34.757-29.63-40.487-48.325
  c-1.731-5.652-2.044-11.03-1.31-16.545c98.826,37.305,145.11,64.109,170.662,89.251c11.496-30.589,38.3-99.868,78.371-123.646
  c0.191,3.77-1.309,7.837-4.357,12.189c11.863-6.609,21.125-17.188,37.445-16.98c-1.879,7.723-7.279,13.904-17.85,17.854
  c10.662-4.084,21.463-7.545,32.65-9.578c10.375-1.881,10.229,6.304,4.355,10.444c-11.916,8.412-24.578,9.456-37.006,13.498
  c38.105,0.949,69.266,18.994,93.604,58.343c8.088,13.074,13.52,26.149,14.807,40.487c16.254,4.563,32.426,5.494,48.76,2.61
  c4.475-0.796,8.645-1.63,12.627-3.482c-6.354,9.529-13.686,17.356-23.947,20.899c-9.811,3.387-19.637,6.688-30.473,6.968
  c17.641,6.675,37.082,7.045,57.033,5.659c-24.402,23.486-43.08,22.922-61.824,22.642c-8.221,34.703-25.025,69.315-60.52,101.005
  c-46.559,41.569-96.678,61.397-148.457,65.742c-48.552,4.07-95.488,3.512-146.726-20.464
  C56.486,393.349,24.648,368.884,0.001,334.932L0.001,334.932z"/></svg></a></li>
</ul>
  
  
  
  
  
  
    
      <form action="http://google.com/search" method="get">
        <fieldset role="search">
          <input type="hidden" name="sitesearch" value="www.toomuchcode.org" />
    
          <input class="search" type="text" name="q" results="0" placeholder="Search"/>
        </fieldset>
      </form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2007/04/08/the-imaginary-concurrency-debate/">The Imaginary Concurrency Debate</a></h1>
    
    
      <p class="meta">
        





        
        
      </p>
    
  </header>


  <div class="entry-content">It&#8217;s finally being accepted: the shared memory, critical region model for concurrent programming is broken.   Even good programmers slip up and introduce race conditions, and bad programmers don&#8217;t even understand the semantics.  (You mean I have to lock an object just to <span style="font-style: italic;">read</span> its values?)<br /><br />The question is: how do we fix it?  Two proposals have drawn attention: The Actor/Message model and Software-Transactional Memory (STM).  The former eliminates shared state entirely, using messaging primitives for communication between threads, which may or may not be in the same process or physical machine.  The latter preserves shared memory, but each thread has a consistent view of shared state during an operation and makes updates atomically, much like a database transaction.  We&#8217;ll refer to these as the <a title="Erlang model" href="http://www-128.ibm.com/developerworks/java/library/j-cb04186.html?ca=drs">Erlang model</a> and the <a title="Haskell model (pdf)" href="http://research.microsoft.com/%7Esimonpj/papers/stm/stm.pdf">Haskell model (pdf)</a>, respectively, referring to the programming languages that most visibly use these synchronization techniques.<br /><br />A debate between these models has quietly arisen.  Proponents of the shared-nothing model point out the scalability and simplicity of Erlang.  Proponents of STM point out the composability of guaranteeing updates to two components can be made atomically.  Incredibly, it seems like this entire debate is ill-formed, and can be resolved with some simple generalization.<br /><br />First we realize nearly all non-trivial applications use both a form of messaging and shared resources.  A simple web application accepts messages from clients and shares state in a database.  Therefore, any widely used programming environment must offer first-class support for transacted resources <span style="font-style: italic;">and</span> messaging.<br /><br />Now, suppose we view transacted memory simply as a hidden optimization of a transacted resource.  In Erlang I can send messages to an Erlang process in the same physical address space or on a different machine &#8211; the former is simply a runtime optimization and not the concern of the developer.  STM is just a local optimization of a transacted resource; with abstraction we can also host the resource remotely like a database or distributed cache.<br /><br />In fact, the Erlang and Haskell models are closer than they first appear.  The STM proposal for Haskell has almost nothing to suggest a TVar must be locally hosted.  There are Erlang libraries allowing use of an RDBMS.   Both of these could be implementations of a general &#8220;transacted resource&#8221; API or Monad.  Similar parallels can be made for the messaging model.  Of course the languages have other significant differences, but these concepts are not so far apart.<br /><br />So where does this leave us in the concurrency debate?  I think we can draw some conclusions:<br /><ul><li>Today&#8217;s concurrency primitives can be abandoned, replaced by messaging and transacted resources</li><li>Messaging and shared resources are complementary constructs used in most applications</li><li>Shared memory is to transacted resources what in-process messaging is to general messaging: a hidden optimization</li><li>Applications should use messages, transactions, or an appropriate combination depending on their needs<br /> </li></ul>  Now we need to ask why no widespread language has yet to replace critical region primitives with messaging and transacted memory.  I think this is largely because such languages are hard to design.  Notice how I&#8217;m generalizing STM and transacted databases to the same concept, but they have very different usage patterns in practice.  It will be a challenge to design something this general yet simple enough so people will actually want to use it.  But I&#8217;m an optimist.<br /><br />One final note: both of these models are more easily implemented using a functional programming style.  Something as simple as immutable objects makes both local messaging and transactions much simpler and more efficient.  It&#8217;s funny how good practices pay off in ways we don&#8217;t expect.</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2007/02/27/imperfect-approximation-of-perfect-code/">Imperfect Approximation of Perfect Code</a></h1>
    
    
      <p class="meta">
        





        
        
      </p>
    
  </header>


  <div class="entry-content">It needs to be said: the quality of a programming language is not inversely proportional to the number of bytes needed for a Sudoku solver.  Not that there&#8217;s anything wrong with comparing Sudoku solvers; they can contrast certain aspects of languages, and differing solution styles can help readers think differently about code.  But this only gets us so far.<br /><br />The problem is the public language debate rarely ranges to topics that span more than a couple dozen lines of code.  Anything bigger is difficult to manage in a single discussion.  Therefore we need a model to debate the higher-order concerns of programming languages.  Fortunately, I&#8217;m shameless, and will shamelessly steal such a model from Donald Norman&#8217;s excellent <a href="http://mitpress.mit.edu/catalog/item/default.asp?tid=5393&ttype=2" title="Design of Everyday Things">Design of Everyday Things</a>.<br /><br />The idea I&#8217;m referring to is Norman&#8217;s modeling of human interaction with software and physical tools as a <span style="font-style: italic;">series of imperfect approximations to approach a perfect goal.</span>  A system should assume all user input is imperfect, but guide the user to her goal.  A user should have feedback indicating progress toward the goal.  Mistakes should be easily reversible and never take her far astray.<br /><br />Let&#8217;s apply this to programming languages and practices.  The biggest step forward in recent years has been the adoption of test-driven development.  This fits nicely &#8211; a solid safety net of unit tests allows developers to move towards the perfect goal.  It also brings to mind a humorous <a href="http://programmingkungfuqi.blogspot.com/2007/02/real-reason-why-building-software-is.html" title="recent post">recent post</a> by <span class="misspell" suggestions="Jet,Jot,Jut,Kt,Jct">Jt</span> Gleason.  One of the reasons programming is harder than bridge building is even small defects can cause us to jump radically away from our goal.<br /><br />So, what can improved languages and practices do to help?  They can guarantee no programmer mistake will cause us to jump to across an ocean, to use Gleason&#8217;s metaphor.  Programming will never be truly analogous to bridge building, but if bugs can be localized &#8211; like how a bad bolt is localized for a bridge &#8211; we might make progress.  We can&#8217;t eliminate bugs, but we can bound them and trend towards perfection.  This reminds me of a <span class="misspell" suggestions="Piety,Poet,PET,Pet,Pit">Piet</span> <span class="misspell" suggestions="He in,He-in,Heine,Hen,Heinz">Hein</span> poem reportedly displayed in Donald Knuth&#8217;s home:<br /><span style="font-style: italic;"></span><blockquote><span style="font-style: italic;"> The road to wisdom? Well, it&#8217;s plain<br /></span><span style="font-style: italic;"> And simple to express:</span><br /><span style="font-style: italic;"> Err</span><br /><span style="font-style: italic;"> and err</span><br /><span style="font-style: italic;"> and err again</span><br /><span style="font-style: italic;"> but less</span><br /><span style="font-style: italic;"> and less</span><br /><span style="font-style: italic;"> and less.</span></blockquote><span style="font-style: italic;"></span>  With all this in mind, I recently saw something that just might be a glimpse of the future.  Giles <span class="misspell" suggestions="Beckett,Becket,Bocked,Booked,Bucket">Bowkett</span> posted a <a href="http://gilesbowkett.blogspot.com/2007/01/seaside-screencasts.html" title="screencast"><span class="misspell" suggestions="screen cast,screen-cast,scrawniest,scroungiest,crankest">screencast</span></a> showing modification of code in a Seaside-based web application as it was running.  Sure, we&#8217;ve been able to hot-swap code for a while, but that&#8217;s usually a painful process requiring specific launch configuration and use of an external debugger.  Imagine if every menu in every program had an &#8220;edit&#8221; button available to experts, allowing them to adjust code on the fly.  The code-build-test-debug loop would become instantaneous, applications could be grown in the context of existing pieces, and good design and languages can prevent local bugs from creeping elsewhere.  This is our series of approximations toward a perfect goal.<br /><br />Of course, the above ideal might be unachievable for many applications.  Even so, it still might be possible to build an imperfect approximation.</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2007/02/09/part-4-the-killer-app/">Part 4&#58; The Killer App</a></h1>
    
    
      <p class="meta">
        





        
        
      </p>
    
  </header>


  <div class="entry-content">Technologies get adopted when there is a compelling reason.  People bought PCs for the killer app; game consoles sold for the killer game.  Programming languages take off because they have a killer feature.  Philip <span class="misspell" suggestions="Waddle,Wader,Adler,Waller,Wailer">Wadler</span> <a title="pointed this out" href="http://citeseer.ist.psu.edu/wadler98why.html">pointed this out</a> nine years ago:<br /><blockquote>Instead, experience shows that users will be drawn to a language if it lets them conveniently do something that otherwise is difficult to achieve. Like other new technologies, functional languages must seek their killer app.</blockquote>Java was adopted largely because it was easy for C++ developers to pick up, and offered killer features like cross-platform development and garbage collection.  So what is the killer feature of the next language?  I&#8217;ll take a shot: the complete and final eradication of undefined behavior.<br /><br /><span style="font-weight: bold;">No Behavior Left Undefined</span><br />&#8220;Undefined behavior&#8221; is the biggest euphemism in software engineering.  It even beats out &#8220;non-trivial problem&#8221;.  It&#8217;s why your code works great on your laptop, but every one of your users runs a <a title="DeathStation 9000" href="http://en.wikipedia.org/wiki/DeathStation_9000"><span id="bad_word" class="misspell" suggestions="Death Station,Death-Station,Detestation,Devastation,Dissertation">DeathStation</span> 9000</a>.  Amazingly, most mainstream languages still have areas where behavior is undefined and unpredictable.<br /><br />Fortunately, modern languages have made great strides as compared to, say, C++.  However, we still have a long way to go.  The big problem these days is race conditions caused by improperly synchronized code.  And it looks like concurrent programming will only become more common. <br /><br />What makes undefined behavior particularly evil is not that it might fail; it&#8217;s that it might succeed.  We <span style="font-style: italic;">want</span> incorrect code to consistently fail.  This way every time we find a bug we can isolate it with a unit test and ensure it never happens again.  But undefined behavior shoots a hole in this: we can have incorrect code that <span style="font-style: italic;">passes every possible unit test.</span>  The result is bugs showing up in the worst possible place, production.<br /><br />Consider the practical implications of working in a language without undefined behavior.  If we can create a reliable unit test for any bug we find, we can guarantee that bug never recurs.  Good development practices can cause defect counts to trend towards zero.  It also makes development itself easier by strengthening our <a title="firewall against complexity" href="http://toomuchcode.blogspot.com/2007/02/building-firewall-against-complexity.html">firewall against complexity</a>.  Although we&#8217;ll never eliminate buggy code, hopefully we can create enough stability to prevent bugs from spiraling out of control, which has led to the death of many projects.<br /><span style="font-weight: bold;"><br /><span style="font-weight: bold;">Where is our new language?</span></span><br />The <a title="first" href="http://toomuchcode.blogspot.com/2007/02/part-1-programming-and-metaphorical.html">first</a> <a title="three" href="http://toomuchcode.blogspot.com/2007/02/part-2-languages-and-lesser-skilled.html">three</a> <a title="posts" href="http://toomuchcode.blogspot.com/2007/02/building-firewall-against-complexity.html">posts</a> and this one describe an ideal for a new programming language.  Many details were intentionally left out to focus on the essence, so many language styles might work.  Now I have a question for you: what current or upcoming language best meets these ideals?  Much of this exists in part in Haskell, Erlang, Ruby, <span class="misspell" suggestions="Scalar,Scale,Scaly,Scald,Scalp">Scala</span>, F# or others, but I know of no language meeting them all.  I hope that will change soon.    <span style="font-weight: bold;"><span style="font-weight: bold;"></span><br /></span><br />Thanks to everyone who made it through these posts.  I do want to hear your thoughts.</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2007/02/09/part-3-building-a-firewall-against-complexity/">Part 3&#58; Building a Firewall Against Complexity</a></h1>
    
    
      <p class="meta">
        





        
        
      </p>
    
  </header>


  <div class="entry-content">In the <a title="first" href="http://toomuchcode.blogspot.com/2007/02/part-1-programming-and-metaphorical.html">first</a> <a title="two" href="http://toomuchcode.blogspot.com/2007/02/part-2-languages-and-lesser-skilled.html">two</a> posts in this sequence, I argued a few key points:<br /><ul><li> A language must be usable by mediocre developers to achieve widespread use.</li><li> A language that prevents quick and dirty application development will not be widely adopted.</li><li>Widespread adoption is important so good programmers can use better languages in their day jobs.</li><li>Haskell shows important innovation in language design, but has major hurdles to widespread adoption.<br /></li></ul>Assuming the above, we have a big problem: how do we make the essential innovation in Haskell available to the broader industry?  We need to first define the essence of Haskell&#8217;s contribution, and then look for ways to package that essence for widespread use.<br /><br />I will use a simple model of software problems to define Haskell&#8217;s essential contribution.  Complexity kills, but Haskell helps contain it<span style="font-style: italic;">.</span>  We were in trouble the moment systems got too big for a single human to understand, and we kept digging the hole deeper.  This needs to stop.<br /><br />So far the best answer to complexity has been good design abstraction.  And there have been successes &#8211; I usually don&#8217;t think about the virtual memory system when writing code, for instance.  But as Joel Spolsky pointed out, &#8221;<a title="All non-trivial abstractions, to some degree, are leaky." href="http://www.joelonsoftware.com/articles/LeakyAbstractions.html">All non-trivial abstractions, to some degree, are leaky</a>.&#8221;  I don&#8217;t <span style="font-style: italic;">usually</span> think about virtual memory, but if I have locality of reference problems and huge numbers of page faults, the abstraction leaks.   Suddenly I have to think about everything my program does, everything its libraries do, all existing abstraction leaks, <span style="font-style: italic;">and</span> the virtual memory system.  Soon there isn&#8217;t room in my limited mind to keep track of everything.  The result is almost inevitable: a system gets more complex, details are missed, and defects creep in.<br /><br />To make matters worse, the difficulty of understanding a system grows exponentially with size.  Every variable added must be tracked with every other variable.  I see two possible solutions to this:<br /><ol><li>Stop building such complex software.</li><li>Find ways to build airtight firewalls around complexity.  Stop the leaks.<br /></li></ol>History suggests option one is not likely.  Great programmers can solve complex problems with simple code, but this is not the broader trend.  Even if it was, this answer is unsatisfying; it&#8217;s really just avoiding the problem.<br /><br />The second solution might have potential.  Imagine if we had abstractions that didn&#8217;t leak, even if they could only be used in special conditions, or applied to certain problems.  There will always be complexity, but by bounding it with airtight abstractions we limit the number of variables involved.  Heck, if we do a great job, it&#8217;s possible even we humans will be able to understand the systems we build.<br /><br />This is where we reach the essential contribution of Haskell (or any pure functional language): <span style="font-style: italic;">it builds a firewall around the rest of the system&#8217;s complexity.</span>  You only have to think about the part you&#8217;re working, and you can make that small enough to be understandable.   Because functions can&#8217;t have side effects, you don&#8217;t have to worry about locking a resource or dealing with inconsistent state.  Your universe is defined by a function&#8217;s arguments.<br /><br />So far, so good&#8230;but we still need to package our firewall against complexity to be more easily adopted and used.  Notice large parts of functional languages are not included in the essential contribution.  For instance, a chunk of code could be written in any style, as long as its side effects are encapsulated.  Here we break away from the pure functional model.  If local destructive updates, statements, for loops, or other imperative constructs make coding easier, we can allow them.  The key is not allowing these local decisions escape; our firewall against complexity must hold.  A similar point came up in a recent <a title="discussion on Channel 9" href="http://channel9.msdn.com/Showpost.aspx?postid=273697">discussion on Channel 9</a>.  Erik Meijer described it as &#8220;local impurity, but global purity&#8221;.<br /><br />This is a key element for our hypothetical new language: allow developers to code in their style of choice, provided it does not compromise the system&#8217;s guarantees.  The merits of different styles are open to debate, but surely no one style is the best for all programs.  Ultimately, our hypothetical language might really be a set of languages, all keeping the same guarantee of isolation.  The key is we can build a language with stronger guarantees than any commonly used language, but make it easy for most developers to adopt.<br /><br /><span style="font-weight: bold;">Can we live without state?</span><br />System state is the biggest source of complexity for imperative programs.  It&#8217;s also the biggest reason imperative code is considered easier for quick and dirty solutions.  You want to change state?  Go for it.  Just be sure you synchronize with other threads, and your state change is consistent with the rest of the system, and you leave the system in a consistent state in case of error, and&#8230;well, hope others changing the state follow the same rules.     <br /><br />All of these problems go away with functional languages.  But I can&#8217;t shake the idea that a language restricting all access to state simply won&#8217;t get adopted.  Haskell elegantly solves this solution with the Monad; you write code in isolation, and simply describe the side effects to be evaluated as needed.  Sounds good, until you run into problems like the one described <a title="here" href="http://kawagner.blogspot.com/2006/12/my-haskell-experience.html">here</a>.  In that case, the developer discovered a deep function needed some additional piece of information, and had to refactor large amounts of code to get it there.  This drawback may well be justified by the advantages of isolated coding.  Then again, our goal is to get a better language adopted, and most businesses will reject one that makes writing quick and dirty code harder, even if there is a net gain.<br /><br />I really hope I&#8217;m wrong about this one.  (And I&#8217;m sure many will try to convince me that I am.)   I suspect, though, that languages must make accessing state information easy to gain widespread adoption.  Is there a way we can do this while holding on to our firewall against complexity?  Maybe.  There are some tempting ideas that might solve this.  Possibilities include <a title="Software Transactional Memory" href="http://en.wikipedia.org/wiki/Software_transactional_memory">Software Transactional Memory</a> (STM), or messaging-based models like Erlang.  The answer to which is better must come from experimentation, although STM elegantly solves some problems others do not, as <a title="Tim Sweeny described (pdf)." href="http://morpheus.cs.ucdavis.edu/papers/sweeny.pdf">Tim Sweeny described (pdf).</a>   Assuming an adopted system must be able to easily change state, we can still use STM to attain many advantages of the functional style:<br /><ul><li>No race conditions or deadlock.  STM can make code seem like it&#8217;s running in a single-threaded environment.  This is our firewall against concurrency complexity.</li><li> No inconsistent state.  If any error occurs, the transaction is simply rolled back.  As a result, the state space of the system is dramatically reduced, and all possible states are logically consistent.</li><li>External side effects (like database updates) should happen in the same transaction as memory updates, again ensuring consistent state.<br /></li></ul>A new language could allow only special annotated functions to use STM, clearly indicating which functions are logically pure.  This is analogous to implicitly passing a Haskell Monad to every pertinent function.  Yes, we are sacrificing functional purity.   However, we keep our firewall, and build a language that just might find a widespread audience.  Also, we need not sacrifice other great features of functional languages to get there.  For instance, a function may do destructive updates internally but always return an immutable object, lending itself to memoization.<br /><br />In summary, we have two new requirements for our hypothetical language:<br /><span style="font-style: italic;"><blockquote>Developers should be able to choose their style of programming, but still have strong guarantees of isolation from the rest of the system.</blockquote><span style="font-style: italic;"></span></span><blockquote><span style="font-style: italic;"><span style="font-style: italic;">The system should limit the number of variables the developer must track while writing code.</span><br /></span></blockquote>In my next post, I will add more requirements in this spirit, and hopefully draw these thoughts to a close.</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2007/02/07/part-2-languages-and-the-lesser-skilled-developer/">Part 2&#58; Languages and the Lesser-Skilled Developer</a></h1>
    
    
      <p class="meta">
        





        
        
      </p>
    
  </header>


  <div class="entry-content">My <a title="last post" href="http://toomuchcode.blogspot.com/2007/02/part-1-programming-and-metaphorical.html">last post</a> ended with an assertion: we need a language with the best of Haskell in a more accessible form.  This leads to an old debate.  After all, building good software requires tremendous skill.  How can we make progress if we tailor it to the weakest practitioners?  Bjarne Stroustrup <a href="http://www.technologyreview.com/Infotech/17868/page1/" title="made this point well">made this point well</a>:<br /><blockquote> The idea of programming as a semiskilled task, practiced by people with a few months&#8217; training, is dangerous. We wouldn&#8217;t tolerate plumbers or accountants that poorly educated. We don&#8217;t have as an aim that architecture (of buildings) and engineering (of bridges and trains) should become more accessible to people with progressively less training. Indeed, one serious problem is that currently, too <i>many</i> software developers are undereducated and undertrained.</blockquote>Stroupstrup is right, of course.  Too many developers <span style="font-style: italic;">are</span> undereducated; we <span style="font-style: italic;">should</span> demand greater skill.   However, this doesn&#8217;t change the fact that language adoption for a given shop has as much to do with politics as technical merit.  Businesses have a perceived need to hire armies of developers to quickly write bad code and bad software.  We&#8217;ll be asking &#8221;<a title="WTF" href="http://thedailywtf.com/">WTF</a>?&#8221; for a long time to come.<br /><br />The problem is highly skilled developers are often forced to use the languages accessible to their less competent colleagues.  Browse the forums at <a title="Reddit" href="http://reddit.com/">Reddit</a> and you&#8217;ll find lots of developers coding C# or Java by day and Haskell or Lisp by night.  In short, a language must be usable by lesser-skilled developers so high-skilled developers have more opportunities to use it.   Ruby is a great example of this in action &#8211; building a quick and dirty web application is trivial, but the language still offers powerful constructs such as closures.<br /><br /><span style="font-weight: bold;">Battling the Hack</span><br /><span style="font-weight: bold;"></span>Anyone who has written software for a couple years has come across the Nasty Hack &#8211; what should have been a simple piece of code made horribly complex, requiring an alignment of planets to work.  Languages such as Haskell have the laudable goal of <a title="preventing nasty hacks" href="http://neilbartlett.name/blog/?p=11">preventing nasty hacks</a> by <a title="restricting what can be done in a given context" href="http://syntaxfree.wordpress.com/2007/01/08/haskell-bondage-and-discipline-and-separation-of-concerns-programming/">restricting what can be done in a given context</a>.  Sadly, good design often takes second place to deadlines &#8211; and a language that has the appearance of slowing development won&#8217;t get far, even if it offers a net gain.<br /><br />Even a language that prevents some classes of nasty hacks will <a title="allow other kinds" href="http://trevion.blogspot.com/2006/11/functional-anti-patterns.html">allow others</a>.  No language will free us from bad code altogether.  Even worse, languages that free us from large classes of bad code have trouble getting adopted because businesses indirectly want to hack.  This has depressing implications:  the nasty hack is here to stay, and languages attempting to eliminate it will struggle to find widespread adoption.  Our only hope is a fundamental cultural change in the way most organizations build software.<br /><br />There is nothing I want to see more than this cultural shift.  Maybe some day the market will get so sick of bad software it will force change.  Consumers might realize great software<span style="font-style: italic;"> is </span>possible, as shown by a few innovative companies.   Other companies might finally delay entry to a market, knowing a buggy solution will be rejected.   The lesser-skilled developer might be forced to improve or leave the field.<br /><br />However, while attempting to change the culture we still need to innovate under the current constraints.  This means it must be easy to write quick and dirty code in a widely adopted language.  So I submit a requirement for our new language:<br /><span style="font-style: italic;"><blockquote>A language should encourage good code &#8211; but make quick and dirty code possible.</blockquote></span>Today languages like Ruby and Python are probably the closest to the mark.  Inexperienced developers can quickly get code working, and more advanced developers have access to powerful features drawn from the functional world.  However, both of these languages have shortcomings when compared to Haskell.  Incorrect code can lead to unpredictable behavior, and poorly designed code can lead to a state space too big for any human to understand.  Specifically, they do not offer a tractable solution to <a title="concurrency and composability" href="http://research.microsoft.com/%7Esimonpj/papers/stm/stm.pdf">concurrency and composability</a> (pdf).<br /><br />In my next post I will attempt to outline a language concept drawing from the best of Ruby, Haskell, and other sources.<br /><br />(Edit: fix typo)
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2007/02/03/part-1-programming-and-the-metaphorical-mind/">Part 1&#58;  Programming and the Metaphorical Mind</a></h1>
    
    
      <p class="meta">
        





        
        
      </p>
    
  </header>


  <div class="entry-content"><span style="font-weight: bold;">Hello, World</span><br />This is the first of a set of posts on what we need from a new programming language.  Everything I discuss exists in some language &#8211; at least in part &#8211; but no language yet has them all.  This content is a mixture of my experience and many borrowed ideas, which I will do my best to cite.  My goal is to represent the language needs of some segment of developers.<br /><br /><span style="font-weight: bold;">The Metaphorical Mind</span><br />I&#8217;ll start simply: a language must be designed and taught with its users in mind.  There is a psychology to programming which may explain why some languages get adopted and better ones don&#8217;t.  To model this psychology, I borrow the idea of the &#8220;Metaphorical Mind&#8221;<span style="font-style: italic;"><span style="font-style: italic;">,</span></span> as described in Steven Pinker&#8217;s excellent <a title="How the Mind Works" href="http://pinker.wjh.harvard.edu/books/htmw/index.html">How the Mind Works</a>.   In Pinker&#8217;s words, &#8220;The human mind, we see, is not equipped with an evolutionarily frivolous faculty for doing Western science, mathematics, chess, or other diversions.&#8221;  Our minds evolved to work with the physical world, and we reason with abstract ideas using physical metaphors.  Pinker cites Ray Jackendoff for examples:<br /><br />The messenger <span style="font-style: italic;">went from</span> Paris <span style="font-style: italic;">to</span> Istanbul.<br />The inheritance finally <span style="font-style: italic;">went to </span>Fred.<br />The light <span style="font-style: italic;">went from</span> green <span style="font-style: italic;">to</span> red.<br />The meeting <span style="font-style: italic;">went from</span> 3:00 <span style="font-style: italic;">to</span> 4:00.<br /><br />(emphasis in original)<br /><br />The first sentence shows physical movement; the others use the same terms but have nothing moving.  Beyond movement, spatial metaphors permeate our thoughts and language.  &#8220;The meeting is <span style="font-style: italic;">at</span> 3:00&#8221;, for instance.  In fact, it&#8217;s hard to describe almost anything without physical metaphors.<br /><br />Many examples exist in software.  Imperative programmers deal with <span style="font-style: italic;">pointers, objects, stacks, messages, events</span> and so on.  Our secondary storage uses <span style="font-style: italic;">folders, files</span> and <span style="font-style: italic;">paths.</span><br /><br />In fact, there is an alarming predictability on language adoption: languages that strengthen the physical metaphor &#8211; or at least solve problems without weakening it &#8211; have found widespread use.  Languages with weaker physical metaphors remain with a small base.  Compare the adoption rates of object-oriented languages to their functional counterparts.<br /><br />This might be an indictment of functional languages, since they are typical expressed in abstract mathematics rather than physical analogs.  That is unfair.  Functional languages can be built and explained in straightforward physical terms &#8211; they just aren&#8217;t.  Take, for instance, Haskell&#8217;s Monad.  I&#8217;ve written only small programs in Haskell, but for my purposes it&#8217;s much easier to think of a Monad as a &#8220;to-do list&#8221;.  (Some use the term &#8220;action&#8221;.  I know it&#8217;s an over-simplification, but that&#8217;s the point.)  The bulk of the language is a means to construct to-do lists in isolation.  Put in these terms, Haskell can be simpler than many languages &#8211; the functional purity eliminates all kinds of moving parts imperative programmers have to worry about.<br /><br />This is a good step, but widespread adoption means more than renaming of concepts.  Unfortunately, programmers who find and learn functional languages are not representative of the population.  I&#8217;m afraid we would lose a broader audience in the first hour of learning Haskell, as soon as they got to this:<br /><br /><code>fibs = 1: 1: zipWith (+) fibs (tail fibs)</code><br /><br />Beautiful, isn&#8217;t it?  One line of code for Fibonacci numbers, what amounts to built-in memoization, the ability to get and manipulate any sequence, and so on.  But it also has only the weakest of ties to a physical analog.  Non-trivial examples are much harder to understand.  Sadly, an incredibly powerful tool for some is simply too abstract for others to use effectively.<br /><br />Because of this and other examples, I doubt Haskell will ever be widely used despite all of its advantages.  But this is okay &#8211; we need powerful tools for the hands of experts.  What I want to see is a more accessible language borrowing the best ideas from Haskell and others.  I wish I could use Monads every day, and am willing to sacrifice some of Haskell&#8217;s other power to achieve this.<br /><br />This raises an important question: shouldn&#8217;t we raise our expectations of developers rather than take away powerful features?  A valid point, which I will tackle this in my next post.<span style="font-style: italic;"></span>  For now, the central thesis of these posts should start to emerge: we need a language with the best parts of Haskell and others in a more accessible form.</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2006/12/26/the-software-engineers-new-clothes/">The Software Engineer&#8217;s New Clothes</a></h1>
    
    
      <p class="meta">
        





        
        
      </p>
    
  </header>


  <div class="entry-content">The problem with experts is they&#8217;re too smart.  The problem with the rest of us is we don&#8217;t have the expertise to reign in the experts.<br /><br />Consider the following conversation:<br /><br /><span style="font-weight: bold;">Mortal Developer:</span> This system seems complicated.  Can we do without the WhackAMole feature?<br /><span style="font-weight: bold;">Expert: </span>No, some clients might need WhackAMole to interact with their legacy abacus.<br /><br />Now our poor mortal developer is stumped.  After all, this is the <span style="font-style: italic;">expert</span> we&#8217;re talking to here &#8211; and if he says we need WhackAMole you better get whacking.<br /><br />What our developer missed is this: <span style="font-style: italic;">complexity alone is enough to reject a design.</span>  After all, you&#8217;re a smart engineer with years of programming experience.  Even if you&#8217;re not an expert, if a system is hard for you to comprehend, it&#8217;s probably too complicated.  Sadly, there seems to be an &#8220;Emperor&#8217;s New Clothes&#8221; phenomenon in software  &#8211; no one wants to admit something is hard to understand.<br /><br />This shouldn&#8217;t be surprising &#8211; objecting to complexity might be viewed as looking stupid in an industry where intelligence is the highest virtue.  Unfortunately this can do a lot of harm.  Imagine if the J2EE specification had involved a developer without expertise, but with veto power.  Surely the result would have been a lot simpler.  This lesson may have been learned for newer versions, but once added this complexity cannot be completely removed.<br /><br />For anyone that might be struggling with this right now, some humble advice:<br /><ul><li>Follow Alan Kay&#8217;s axiom: &#8220;Simple things should be simple, complex things should be possible.&#8221; &#8211; If something complicated <span style="font-style: italic;">must </span>be in the system, it still should not affect the simple things.</li></ul><ul><li>View the project as a constant battle against complexity &#8211; A single complex module may seem unimportant, but it quickly compounds.</li></ul><ul><li>Understand a project end-to-end &#8211; the project should be easily broken down into problems that are known to be solvable.  (Avoid Southpark&#8217;s 1. Collect Underpants. 2. ??? 3. Profit!!!).   </li></ul><ul>   <li>       A strong-willed engineer or executive can will a group down the wrong path &#8211; it&#8217;s an engineer&#8217;s duty to object and prevent spiraling complexity</li></ul><ul><li>The clever hack should be a last resort &#8211; a hack that is hard to come up with is much harder to debug or support<br /></li></ul>All of this boils down to Keep It Simple, Stupid.  It turns out keeping things simple is pretty hard.<br /><br />Update: This isn&#8217;t to suggest that all experts fall into this trap, but there is certainly evidence suggesting that <span style="font-style: italic;">some</span> do.</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2006/11/15/the-real-reason-we-need-strongly-typed-languages/">The real reason we need strongly-typed languages</a></h1>
    
    
      <p class="meta">
        





        
        
      </p>
    
  </header>


  <div class="entry-content">There aren&#8217;t many hard-and-fast facts about software, but here&#8217;s one:<br /><br />    The more code you have, the more bugs you have.<br /><br />More formally, lines of code is a strong predictor of defects.  So, any language that allows you to do the same work with less code must be a Good Thing.  This is why Python is better than Java is better than C++ is better than assembly, right?<br /><br />Well, almost.  The standard counter argument is strongly-typed languages catch mistakes at compile time that slip to run time for dynamic languages.   I don&#8217;t buy this argument, because  even though it will catch <span style="font-style: italic;">some</span> mistakes, there are so many other errors to be made you still need to unit test the code.  And good unit tests will catch the same errors of strongly-typed languages.  Okay, so a lot of people don&#8217;t write good unit tests, but until they do they&#8217;re beyond our help anyway.  As Bruce Eckel said, <a href="http://www.mindview.net/WebLog/log-0025" title="if it's not tested, it's broken">&#8220;if it&#8217;s not tested, it&#8217;s broken&#8221;</a>.<br /><br />So why am I a proponent of strongly-typed languages for many (but not all) problem sets?  Because they give us one thing dynamic languages by definition never will: unambiguous, guaranteed documentation.   Building large software systems means interfacing with subsystems written by others, and they must be documented.  Strongly-typed languages have an important part of that documentation built in: they precisely define the input and output types of each procedure call.  An API in a dynamic language needs the same documentation anyway, so why provide the chance for error?  Even for well-documented libraries, the reduced amount of code in the dynamic language is balanced by increased documentation.<br /><br />In fact, I&#8217;d like to see languages with even stronger guarantees.  A <a href="http://nice.sourceforge.net/language.html" title="Nice">Nice</a> addition to Java would be to define references that can never be null.  Many times I&#8217;ve used an API and asked, &#8220;do I need to check for null?&#8221;  The answer to my question should be part of the API itself.<br /><br />Of course, specific dynamic languages may have other advantages over their strongly-typed counterparts.  Also, some programs may not need the detailed level of documentation offered by strong typing.  Even so, type definitions are a key part of the documentation needed for a large system.</div>
  
  


    </article>
  
  <div class="pagination">
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section><h1>Twitter</h1>
<a class="twitter-timeline" href="https://twitter.com/ryanbrush" data-widget-id="477774048554795009">Tweets by @ryanbrush</a>
<script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+"://platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>
</section>


  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2015 - Ryan Brush -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a> | Themed with <a href="https://github.com/lucaslew/whitespace">Whitespace</a></span>
</p>

</footer>
  










  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
