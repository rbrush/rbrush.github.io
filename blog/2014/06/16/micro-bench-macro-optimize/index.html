
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Micro Benchmarks versus Macro Optimizations in Clojure - Too Much Code</title>
  <meta name="author" content="Ryan Brush">

  
  <meta name="description" content="Here&rsquo;s a simple question Clojure users hear often: What is the overhead of Clojure&rsquo;s persistent data structures? I ran into this question &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://www.toomuchcode.org/blog/2014/06/16/micro-bench-macro-optimize">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="Too Much Code" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=Open+Sans" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=Fjalla+One" rel="stylesheet" type="text/css">
<!--- MathJax Configuration -->
<script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-2927953-1', 'auto');
    ga('send', 'pageview');

  </script>



</head>

<body   class="collapse-sidebar sidebar-footer" >
  <header role="banner"><hgroup>
  <h1><a href="/">Too Much Code</a></h1>
  
    <h2>Not enough cohesion</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscribe" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS" target="_blank"><svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="25" height="25" viewbox="0 0 100 100"><path class="social" d="M 13.310204,73.332654 C 5.967347,73.332654 0,79.322448 0,86.621428 c 0,7.338776 5.967347,13.262246 13.310204,13.262246 7.370408,0 13.328572,-5.92245 13.328572,-13.262246 0,-7.29898 -5.958164,-13.288774 -13.328572,-13.288774 z M 0.01530612,33.978572 V 53.143878 C 12.493878,53.143878 24.229592,58.02347 33.068368,66.865306 41.894898,75.685714 46.767346,87.47449 46.767346,100 h 19.25 C 66.017346,63.592858 36.4,33.979592 0.01530612,33.978572 l 0,0 z M 0.03877552,0 V 19.17449 C 44.54796,19.17551 80.77551,55.437756 80.77551,100 H 100 C 100,44.87653 55.15102,0 0.03877552,0 z"></path></svg></a></li>
  
</ul>
  
  
  
  
  
<ul class="subscribe">
  <li><a href="https://github.com/rbrush" rel="subscribe-github" title="@rbrush on GitHub" target="_blank"><svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="25" height="25" viewbox="0 0 100 100"><path class="social" d="M 50,0 C 22.385714,0 0,22.385714 0,50 0,77.614286 22.385714,100 50,100 77.614286,100 100,77.614286 100,50 100,22.385714 77.614286,0 50,0 z m 29.692858,79.692858 c -3.859184,3.859182 -8.351022,6.887754 -13.35,9.00306 -1.27041,0.536736 -2.560204,1.009184 -3.867348,1.415306 v -7.493878 c 0,-3.938774 -1.35102,-6.835714 -4.053062,-8.690816 1.692858,-0.163264 3.24694,-0.390816 4.663266,-0.683672 1.416326,-0.292858 2.913266,-0.716328 4.491838,-1.27041 1.57857,-0.55408 2.994896,-1.213264 4.247958,-1.97755 1.253062,-0.765306 2.458164,-1.758164 3.613266,-2.978572 1.155102,-1.220408 2.12449,-2.604082 2.905102,-4.15 0.780612,-1.545918 1.4,-3.40204 1.855102,-5.566326 0.455102,-2.164286 0.683674,-4.54898 0.683674,-7.153062 0,-5.045918 -1.643878,-9.341836 -4.931634,-12.890816 C 77.44796,33.35 77.285714,29.10204 75.463266,24.512244 l -1.22143,-0.145918 c -0.845918,-0.09796 -2.368366,0.260204 -4.565306,1.07449 -2.196938,0.814286 -4.663264,2.14796 -7.396938,4.004082 -3.87449,-1.07449 -7.893878,-1.611224 -12.061224,-1.611224 -4.19898,0 -8.203062,0.536734 -12.012246,1.611224 -1.72449,-1.17245 -3.361224,-2.139796 -4.907142,-2.905102 C 31.753062,25.77449 30.516326,25.254082 29.587756,24.97653 28.660204,24.7 27.79796,24.528572 27,24.463266 c -0.79796,-0.0653 -1.310204,-0.08062 -1.537756,-0.04898 -0.22755,0.03164 -0.390816,0.0653 -0.487754,0.09796 -1.82347,4.62245 -1.985714,8.87143 -0.487756,12.743878 -3.287754,3.54796 -4.931632,7.844898 -4.931632,12.890816 0,2.604082 0.227552,4.988776 0.683674,7.153062 0.456122,2.164286 1.07449,4.020408 1.855102,5.566326 0.780612,1.545918 1.75,2.929592 2.905102,4.15 1.155102,1.220408 2.360204,2.213266 3.613264,2.978572 1.253062,0.766326 2.669388,1.42449 4.24796,1.97755 1.578572,0.554082 3.07551,0.976532 4.491836,1.27041 1.416328,0.292856 2.970408,0.521428 4.663266,0.683672 -2.669388,1.82347 -4.004082,4.720408 -4.004082,8.690816 v 7.639796 C 36.536734,89.818368 35.083674,89.3 33.656122,88.695918 c -4.99898,-2.115306 -9.490816,-5.143878 -13.35,-9.00306 -3.859184,-3.859184 -6.887754,-8.351022 -9.00306,-13.35 C 9.1163263,61.171428 8.0071428,55.67347 8.0071428,50 c 0,-5.67347 1.1091835,-11.171428 3.2969392,-16.342858 2.115306,-4.998978 5.143878,-9.490816 9.00306,-13.35 3.859184,-3.859182 8.351022,-6.887754 13.35,-9.00306 C 38.828572,9.1163266 44.32653,8.0071428 50,8.0071428 c 5.67347,0 11.171428,1.1091838 16.342858,3.2969392 5,2.115306 9.490816,5.143878 13.35,9.00306 3.859182,3.859184 6.887754,8.351022 9.00306,13.35 2.186736,5.17245 3.295918,10.67041 3.295918,16.342858 0,5.672448 -1.109182,11.171428 -3.296938,16.342858 -2.115306,4.998978 -5.143878,9.490816 -9.00204,13.35 l 0,0 z"></path></svg></a></li>
</ul>
  
  
  
<ul class="subscribe">
  <li><a href="https://twitter.com/ryanbrush" rel="subscribe-twitter" title="@ryanbrush on Twitter" target="_blank"><svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="25" height="25" viewBox="0 0 512 512"><path class="social" d="M0.001,334.932c33.327,30.816,118.891,59.981,188.517-8.271c-12.52,1.955-22.972-0.416-30.913-8.269
  c-7.531-7.465-7.945-15.182-3.914-22.202c3.275-5.725,10.184-9.741,16.977-13.934c-12.323,2.285-22.829,1.095-32.218-3.706
  c-12.604-6.444-24.863-13.228-28.3-27.207c7.71-8.112,16.28-15.359,34.831-12.627c-17.45-5.83-33.087-13.429-44.41-24.815
  c-11.028-11.091-12.163-18.302-13.932-26.996c9.632-3.567,19.688-5.421,30.478-4.353c-24.397-12.476-34.757-29.63-40.487-48.325
  c-1.731-5.652-2.044-11.03-1.31-16.545c98.826,37.305,145.11,64.109,170.662,89.251c11.496-30.589,38.3-99.868,78.371-123.646
  c0.191,3.77-1.309,7.837-4.357,12.189c11.863-6.609,21.125-17.188,37.445-16.98c-1.879,7.723-7.279,13.904-17.85,17.854
  c10.662-4.084,21.463-7.545,32.65-9.578c10.375-1.881,10.229,6.304,4.355,10.444c-11.916,8.412-24.578,9.456-37.006,13.498
  c38.105,0.949,69.266,18.994,93.604,58.343c8.088,13.074,13.52,26.149,14.807,40.487c16.254,4.563,32.426,5.494,48.76,2.61
  c4.475-0.796,8.645-1.63,12.627-3.482c-6.354,9.529-13.686,17.356-23.947,20.899c-9.811,3.387-19.637,6.688-30.473,6.968
  c17.641,6.675,37.082,7.045,57.033,5.659c-24.402,23.486-43.08,22.922-61.824,22.642c-8.221,34.703-25.025,69.315-60.52,101.005
  c-46.559,41.569-96.678,61.397-148.457,65.742c-48.552,4.07-95.488,3.512-146.726-20.464
  C56.486,393.349,24.648,368.884,0.001,334.932L0.001,334.932z"/></svg></a></li>
</ul>
  
  
  
  
  
  
    
      <form action="http://google.com/search" method="get">
        <fieldset role="search">
          <input type="hidden" name="sitesearch" value="www.toomuchcode.org" />
    
          <input class="search" type="text" name="q" results="0" placeholder="Search"/>
        </fieldset>
      </form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      
        <h1 class="entry-title">Micro Benchmarks versus Macro Optimizations in Clojure</h1>
      
    
    
      <p class="meta">
        





        
        
      </p>
    
  </header>


<div class="entry-content"><p>Here&rsquo;s a simple question Clojure users hear often:</p>

<blockquote><p>What is the overhead of Clojure&rsquo;s persistent data structures?</p></blockquote>

<p>I ran into this question headlong when profiling and tuning <a href="https://github.com/rbrush/clara-rules">Clara</a>. Clara aims to draw ideas from expert systems into the Clojure ecosystem, making them available as first-class Clojure idioms. Therefore Clara&rsquo;s working memory works like other Clojure data structures: it is immutable and &ldquo;updates&rdquo; create a new, immutable working memory.</p>

<p>Anyone skeptical of the benefits of immutability should go watch Rich Hickey&rsquo;s talks like <a href="http://www.infoq.com/presentations/Simple-Made-Easy">Simple Made Easy</a>. Yet these advantages are irrelevant if they don&rsquo;t perform well enough. So we have a challenge: we know that persistent Clojure structures will lose a micro benchmark comparison to mutable counterparts, but can we balance that with macro optimizations made possible with immutability? The answer is <em>yes</em>, with the techniques below working for Clara and probably for many other projects.</p>

<h2>Optimizing Clojure Code</h2>

<p>Optimizations should have an objective. My objective with Clara was to make performance at least competitive with latest version of Drools, which may be used to solve similar problems. Clara&rsquo;s basis in Clojure offers a number of advantages, but we need to make sure performance isn&rsquo;t a barrier. So I created the <a href="https://github.com/rbrush/clara-benchmark">clara-benchmark</a> project, using <a href="https://github.com/hugoduncan/criterium">Criterium</a> to benchmark a number of flows in both Clara and Drools. Some findings:</p>

<h3>It&rsquo;s All About the Algorithms</h3>

<p>The first run of profiling didn&rsquo;t look good. Clara was almost ten times slower than Drools for some cases. But it turns out the bulk of this cost had nothing to do with Clojure &mdash; my variation of the Rete algorithm was inefficient, indexing facts for join operations that could never occur due to the nature of the rules. In short, my algorithm sucked.</p>

<p>The good news this was easily exposed with a profiling tool and fixed with little effort. I find algorithms in a language like Clojure to be easier to understand and tune because they are expressed as simple transformations of data. We know the structures we receive and return, and simply need to identify the most efficient way to express the transformation. This is a major contrast to systems that force us keep track of a bunch of additional state when working through the system.</p>

<p>A better algorithm was the biggest single improvement, bringing Clara within twice Drools performance or better for the use cases tested. But we&rsquo;re not done yet.</p>

<h3>Strongly Isolated Mutability</h3>

<p>A better algorithm got us close, but further profiling revealed a bottleneck for some use cases. Rete engines often perform joins over common facts, like this simple example:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='clj'><span class='line'><span class="p">(</span><span class="nf">defquery</span> <span class="nv">orders-by-customer-id</span>
</span><span class='line'>  <span class="s">&quot;Returns the orders for the given customer.&quot;</span>
</span><span class='line'>  <span class="p">[</span><span class="ss">:?id</span><span class="p">]</span>
</span><span class='line'>  <span class="p">[</span><span class="nv">Order</span> <span class="p">(</span><span class="nb">= </span><span class="nv">?id</span> <span class="nv">customerId</span><span class="p">)</span> <span class="p">(</span><span class="nb">= </span><span class="nv">?total</span> <span class="nv">total</span><span class="p">)]</span>
</span><span class='line'>  <span class="p">[</span><span class="nv">Customer</span> <span class="p">(</span><span class="nb">= </span><span class="nv">?id</span> <span class="nv">id</span><span class="p">)])</span>
</span></code></pre></td></tr></table></div></figure>


<p>This queries the working memory to simply find customer and orders with the same id. (See the <a href="https://github.com/rbrush/clara-rules/wiki/Guide">Clara documentation</a> for details on use.)</p>

<p>Clara makes extensive use of Clojure&rsquo;s <code>group-by</code> function to group collections of facts by matching keys. After tuning my algorithm, I discovered that some benchmarks were spending the bulk of their time in <code>group-by</code>. The <code>group-by</code> implementation can be found in <a href="https://github.com/clojure/clojure/blob/master/src/clj/clojure/core.clj">the Clojure source</a>, but here it is for convenience:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='clj'><span class='line'><span class="p">(</span><span class="kd">defn </span><span class="nv">group-by</span>
</span><span class='line'>  <span class="s">&quot;Returns a map of the elements of coll keyed by the result of</span>
</span><span class='line'><span class="s">  f on each element. The value at each key will be a vector of the</span>
</span><span class='line'><span class="s">  corresponding elements, in the order they appeared in coll.&quot;</span>
</span><span class='line'>  <span class="p">{</span><span class="ss">:added</span> <span class="s">&quot;1.2&quot;</span>
</span><span class='line'>   <span class="ss">:static</span> <span class="nv">true</span><span class="p">}</span>
</span><span class='line'>  <span class="p">[</span><span class="nv">f</span> <span class="nv">coll</span><span class="p">]</span>
</span><span class='line'>  <span class="p">(</span><span class="nf">persistent!</span>
</span><span class='line'>   <span class="p">(</span><span class="nf">reduce</span>
</span><span class='line'>    <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">ret</span> <span class="nv">x</span><span class="p">]</span>
</span><span class='line'>      <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">k</span> <span class="p">(</span><span class="nf">f</span> <span class="nv">x</span><span class="p">)]</span>
</span><span class='line'>        <span class="p">(</span><span class="nf">assoc!</span> <span class="nv">ret</span> <span class="nv">k</span> <span class="p">(</span><span class="nb">conj </span><span class="p">(</span><span class="nb">get </span><span class="nv">ret</span> <span class="nv">k</span> <span class="p">[])</span> <span class="nv">x</span><span class="p">))))</span>
</span><span class='line'>    <span class="p">(</span><span class="nf">transient</span> <span class="p">{})</span> <span class="nv">coll</span><span class="p">)))</span>
</span></code></pre></td></tr></table></div></figure>


<p>Notice the use of Clojure transients, which are mutable structures designed to be used locally for efficiency. Clojure takes a pragmatic step here. The goal is to keep our systems easy to reason about, and we can achieve that if no external observer can detect mutability. <code>group-by</code> is a pure function working with immutable structures for all observers, but gains performance by using transients internally.</p>

<p>The trouble I ran into with my benchmarks is that I had many items mapping to the same key. Notice that Clojure&rsquo;s group-by uses a transient map, but that map contains non-transient vectors. So the performance bottleneck arose because this group-by function wasn&rsquo;t &ldquo;transient enough&rdquo; for my particular data.</p>

<p>I worked around this by writing an alternate group-by that better fit my needs. Its internals are hideous but are the result of profiling a couple implementations:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class='clj'><span class='line'><span class="p">(</span><span class="kd">defn </span><span class="nv">tuned-group-by</span>
</span><span class='line'>  <span class="s">&quot;Equivalent of the built-in group-by, but tuned for when</span>
</span><span class='line'><span class="s">   there are many values per key.&quot;</span>
</span><span class='line'>  <span class="p">[</span><span class="nv">f</span> <span class="nv">coll</span><span class="p">]</span>
</span><span class='line'>  <span class="p">(</span><span class="nf">-&gt;&gt;</span> <span class="nv">coll</span>
</span><span class='line'>       <span class="c1">;; Create a mutable map of transient vectors.</span>
</span><span class='line'>       <span class="p">(</span><span class="nb">reduce </span><span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nb">map </span><span class="nv">value</span><span class="p">]</span>
</span><span class='line'>                 <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">k</span> <span class="p">(</span><span class="nf">f</span> <span class="nv">value</span><span class="p">)</span>
</span><span class='line'>                       <span class="nv">items</span> <span class="p">(</span><span class="nb">or </span><span class="p">(</span><span class="nf">.get</span> <span class="o">^</span><span class="nv">java.util.HashMap</span> <span class="nb">map </span><span class="nv">k</span><span class="p">)</span>
</span><span class='line'>                                 <span class="p">(</span><span class="nf">transient</span> <span class="p">[]))]</span>
</span><span class='line'>                   <span class="p">(</span><span class="nf">.put</span> <span class="o">^</span><span class="nv">java.util.HashMap</span> <span class="nb">map </span><span class="nv">k</span> <span class="p">(</span><span class="nf">conj!</span> <span class="nv">items</span> <span class="nv">value</span><span class="p">)))</span>
</span><span class='line'>                 <span class="nv">map</span><span class="p">)</span>
</span><span class='line'>               <span class="p">(</span><span class="nf">java.util.HashMap.</span><span class="p">))</span>
</span><span class='line'>      <span class="c1">;; Make the vectors immutable into a transient map.</span>
</span><span class='line'>      <span class="p">(</span><span class="nb">reduce </span><span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nb">map </span><span class="p">[</span><span class="nb">key </span><span class="nv">value</span><span class="p">]]</span>
</span><span class='line'>                  <span class="p">(</span><span class="nf">assoc!</span> <span class="nb">map key </span><span class="p">(</span><span class="nf">persistent!</span> <span class="nv">value</span><span class="p">)))</span>
</span><span class='line'>                <span class="p">(</span><span class="nf">transient</span> <span class="p">{}))</span>
</span><span class='line'>      <span class="c1">;; Make the map itself immutable.</span>
</span><span class='line'>      <span class="p">(</span><span class="nf">persistent!</span><span class="p">)))</span>
</span></code></pre></td></tr></table></div></figure>


<p>This is more efficient when there are many items that map to the same key in the returned map, since it uses transient values. (The Java HashMap turned out to be the fastest option to build the result here, but it never escapes this function.) This optimization cut some benchmark times in half. Combined with a number of smaller tweaks, this brought most of Clara&rsquo;s use cases inline with Drools performance. For other use cases Clara significantly outperforms Drools, but we&rsquo;ll get to those later.</p>

<p>My <code>tuned-group-by</code> function is faster than Clojure&rsquo;s <code>group-by</code> for some inputs and slower for others. But this misses a bigger advantage: <strong><em>Clojure&rsquo;s philosophy of separating functions and data made swapping implementations trivial, allowing users to pick the right ones for their specific needs.</em></strong> This isn&rsquo;t so easily done if functions are strongly tied to the data they work with, which is an easy pitfall of object-oriented programming.</p>

<h3>Referential Transparency Breeds Serendipity</h3>

<p>Writing functional code tends to create pleasant surprises. We come across significant advantages that wouldn&rsquo;t be possible with a different approach. Considering the following Clara example and it&rsquo;s Drools equivalent:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='clj'><span class='line'><span class="p">(</span><span class="kd">ns </span><span class="nv">clara.benchmark.visit-order-same-day</span>
</span><span class='line'>  <span class="p">(</span><span class="ss">:require</span> <span class="p">[</span><span class="nv">clara.rules</span> <span class="ss">:refer</span> <span class="ss">:all</span><span class="p">]</span>
</span><span class='line'>            <span class="p">[</span><span class="nv">clj-time.coerce</span> <span class="ss">:as</span> <span class="nv">coerce</span><span class="p">])</span>
</span><span class='line'>  <span class="p">(</span><span class="ss">:import</span> <span class="p">[</span><span class="nv">clara.benchmark.beans</span> <span class="nv">Order</span> <span class="nv">Visit</span><span class="p">]))</span>
</span><span class='line'>
</span><span class='line'><span class="p">(</span><span class="nf">defquery</span> <span class="nv">same-day-visit</span>
</span><span class='line'>   <span class="s">&quot;Queries orders that occurred the same day as a visit.&quot;</span>
</span><span class='line'>   <span class="p">[]</span>
</span><span class='line'>   <span class="p">[</span><span class="nv">Order</span> <span class="p">(</span><span class="nb">= </span><span class="nv">?id</span> <span class="nv">customerId</span><span class="p">)</span> <span class="p">(</span><span class="nb">= </span><span class="nv">?day</span> <span class="p">(</span><span class="nf">coerce/to-local-date</span> <span class="nv">time</span><span class="p">))]</span>
</span><span class='line'>   <span class="p">[</span><span class="nv">Visit</span> <span class="p">(</span><span class="nb">= </span><span class="nv">?id</span> <span class="nv">customerId</span><span class="p">)</span> <span class="p">(</span><span class="nb">= </span><span class="nv">?day</span> <span class="p">(</span><span class="nf">coerce/to-local-date</span> <span class="nv">time</span><span class="p">))])</span>
</span></code></pre></td></tr></table></div></figure>


<p>Drools equivalent:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kn">package</span> <span class="n">clara</span><span class="o">.</span><span class="na">benchmark</span><span class="o">.</span><span class="na">drools</span><span class="o">.</span><span class="na">visit_order_same_day</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'><span class="kn">import</span> <span class="nn">clara.benchmark.beans.Order</span><span class="o">;</span>
</span><span class='line'><span class="kn">import</span> <span class="nn">clara.benchmark.beans.Visit</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'><span class="kn">import</span> <span class="nn">org.joda.time.DateTime</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'><span class="n">query</span> <span class="s">&quot;same_day_visit&quot;</span>
</span><span class='line'>
</span><span class='line'>   <span class="n">Order</span><span class="o">(</span><span class="n">$id</span> <span class="o">:</span> <span class="n">customerId</span><span class="o">,</span> <span class="n">$day</span> <span class="o">:</span> <span class="n">time</span><span class="o">.</span><span class="na">toLocalDate</span><span class="o">())</span>
</span><span class='line'>   <span class="n">Visit</span><span class="o">(</span><span class="n">$id</span> <span class="o">==</span> <span class="n">customerId</span><span class="o">,</span> <span class="n">$day</span> <span class="o">==</span> <span class="n">time</span><span class="o">.</span><span class="na">toLocalDate</span><span class="o">())</span>
</span><span class='line'>
</span><span class='line'><span class="n">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>These rules simply identify things happening on the same day. Yet there is a big difference: Drools does an O(n<sup>2</sup>) Cartesian join where Clara does an O(n*log<sub>32</sub>n) indexed join of each item. Therefore Clara becomes dramatically faster than Drools for large inputs in this case. Also notice how Clara cleanly integrates with Clojure&rsquo;s syntax, as opposed to embedding multiple syntaxes into a file, since it treats <a href="http://www.toomuchcode.org/blog/2013/09/24/rules-as-a-control-structure/">rules as a control structure</a>.</p>

<p>This is possible because of Clojure&rsquo;s emphasis on pure, referentially transparent functions. Since we can replace the function call with its result, we can build an index of that result. The outcome is a significantly more efficient system for this class of problem.</p>

<p>Along the same lines, rule engines facilities to reason over sets of facts can be implemented more efficiently under these constraints. Clara&rsquo;s equivalent of Jess and Drools <em>accumulators</em> simply compile into Clojure <a href="http://clojure.org/reducers">reducers</a>, making them more efficient than the alternatives by simply tapping into that feature.</p>

<p>These advantages arise often: we can defer computation to efficient batch operations. We can transparently spread work across threads without dealing with lock-based concurrency. We can memoize functions or build efficient caches based on fast reference comparison. Importantly, when starting a problem it&rsquo;s not always obvious how these advantages will arise, but these techniques provide an opportunity for great optimizations at the macro level. David Nolen&rsquo;s <a href="http://swannodette.github.io/2013/12/17/the-future-of-javascript-mvcs/">work on Om</a> is a dramatic example of this in action.</p>

<h2>The Trouble with Benchmarks</h2>

<p>X is faster than Y makes for a great incendiary headline on Hacker News, but it doesn&rsquo;t really make sense. X may be faster than Y for workload Z with trade offs A, B, and C&hellip;but for some reason those headlines don&rsquo;t get as many upvotes.</p>

<p>Benchmarks are informative and an important tool to improve our system. But they aren&rsquo;t a real measure of a system&rsquo;s quality or potential. A better measure is how easily a system can be understood, adapted, and expanded. If we can <em>understand</em> the nature of a problem, performance or otherwise, we can usually fix it. Clojure simply provides better mechanisms to understand and improve our systems than other languages I&rsquo;ve used.</p>

<p>In short, the trouble with benchmarks is they encourage treating symptoms rather the than the explosion of complexity that limits what we can build.</p>

<h2>Clara&rsquo;s Future</h2>

<p>All optimizations discussed here are in master and will be released in Clara 0.6.0 this summer. You can see some current comparisons with Drools in the <a href="https://github.com/rbrush/clara-benchmark">clara-benchmark project</a>. There are still opportunities for improvement in Clara, being a relatively new system. Probably the next significant optimization is greater laziness, <a href="https://github.com/rbrush/clara-rules/issues/58">which we&rsquo;re tracking here</a>.</p>

<p>Updates will be posted here and on <a href="https://twitter.com/ryanbrush">my twitter feed</a>. I&rsquo;ll also be discussing modern approaches to expert systems, including Clara, at two conferences over the next few months: <a href="http://www.midwest.io">Midwest.io</a> in July and <a href="https://thestrangeloop.com">strangeloop</a> in September.</p>
</div>


  <footer>
    <p class="meta">
      
  



  <span class="byline author vcard">Authored by <span class="fn">
  
    Ryan Brush
  
  </span></span>


      





      
      


    </p>
    
      <div class="sharing">
  
  <a href="//twitter.com/share" class="twitter-share-button" data-url="http://www.toomuchcode.org/blog/2014/06/16/micro-bench-macro-optimize/" data-via="ryanbrush" data-counturl="http://www.toomuchcode.org/blog/2014/06/16/micro-bench-macro-optimize/" >Tweet</a>
  
  
  
</div>

    
    <p class="meta">
      
        <a class="basic-alignment left" href="/blog/2014/05/17/clara-0-dot-5-released/" title="Previous Post: Clara 0.5 Released">&laquo; Clara 0.5 Released</a>
      
      
        <a class="basic-alignment right" href="/blog/2015/11/11/clara-rules-site/" title="Next Post: Clara Rules Site">Clara Rules Site &raquo;</a>
      
    </p>
  </footer>
</article>


</div>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2015 - Ryan Brush -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a> | Themed with <a href="https://github.com/lucaslew/whitespace">Whitespace</a></span>
</p>

</footer>
  










  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
