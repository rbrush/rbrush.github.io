<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Too Much Code]]></title>
  <link href="http://www.toomuchcode.org/atom.xml" rel="self"/>
  <link href="http://www.toomuchcode.org/"/>
  <updated>2014-06-16T10:31:37-05:00</updated>
  <id>http://www.toomuchcode.org/</id>
  <author>
    <name><![CDATA[Ryan Brush]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Micro Benchmarks versus Macro Optimizations in Clojure]]></title>
    <link href="http://www.toomuchcode.org/blog/2014/06/16/micro-bench-macro-optimize/"/>
    <updated>2014-06-16T07:00:00-05:00</updated>
    <id>http://www.toomuchcode.org/blog/2014/06/16/micro-bench-macro-optimize</id>
    <content type="html"><![CDATA[<p>Here&rsquo;s a simple question Clojure users hear often:</p>

<blockquote><p>What is the overhead of Clojure&rsquo;s persistent data structures?</p></blockquote>

<p>I ran into this question headlong when profiling and tuning <a href="https://github.com/rbrush/clara-rules">Clara</a>. Clara aims to draw ideas from expert systems into the Clojure ecosystem, making them available as first-class Clojure idioms. Therefore Clara&rsquo;s working memory works like other Clojure data structures: it is immutable and &ldquo;updates&rdquo; create a new, immutable working memory.</p>

<p>Anyone skeptical of the benefits of immutability should go watch Rich Hickey&rsquo;s talks like <a href="http://www.infoq.com/presentations/Simple-Made-Easy">Simple Made Easy</a>. Yet these advantages are irrelevant if they don&rsquo;t perform well enough. So we have a challenge: we know that persistent Clojure structures will lose a micro benchmark comparison to mutable counterparts, but can we balance that with macro optimizations made possible with immutability? The answer is <em>yes</em>, with the techniques below working for Clara and probably for many other projects.</p>

<h2>Optimizing Clojure Code</h2>

<p>Optimizations should have an objective. My objective with Clara was to make performance at least competitive with latest version of Drools, which may be used to solve similar problems. Clara&rsquo;s basis in Clojure offers a number of advantages, but we need to make sure performance isn&rsquo;t a barrier. So I created the <a href="https://github.com/rbrush/clara-benchmark">clara-benchmark</a> project, using <a href="https://github.com/hugoduncan/criterium">Criterium</a> to benchmark a number of flows in both Clara and Drools. Some findings:</p>

<h3>It&rsquo;s All About the Algorithms</h3>

<p>The first run of profiling didn&rsquo;t look good. Clara was almost ten times slower than Drools for some cases. But it turns out the bulk of this cost had nothing to do with Clojure &mdash; my variation of the Rete algorithm was inefficient, indexing facts for join operations that could never occur due to the nature of the rules. In short, my algorithm sucked.</p>

<p>The good news this was easily exposed with a profiling tool and fixed with little effort. I find algorithms in a language like Clojure to be easier to understand and tune because they are expressed as simple transformations of data. We know the structures we receive and return, and simply need to identify the most efficient way to express the transformation. This is a major contrast to systems that force us keep track of a bunch of additional state when working through the system.</p>

<p>A better algorithm was the biggest single improvement, bringing Clara within twice Drools performance or better for the use cases tested. But we&rsquo;re not done yet.</p>

<h3>Strongly Isolated Mutability</h3>

<p>A better algorithm got us close, but Clara further profiling revealed a bottleneck for some use cases. Rete engines often perform joins over common facts, like this simple example:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='clj'><span class='line'><span class="p">(</span><span class="nf">defquery</span> <span class="nv">orders-by-customer-id</span>
</span><span class='line'>  <span class="s">&quot;Returns the orders for the given customer.&quot;</span>
</span><span class='line'>  <span class="p">[</span><span class="ss">:?id</span><span class="p">]</span>
</span><span class='line'>  <span class="p">[</span><span class="nv">Order</span> <span class="p">(</span><span class="nb">= </span><span class="nv">?id</span> <span class="nv">customerId</span><span class="p">)</span> <span class="p">(</span><span class="nb">= </span><span class="nv">?total</span> <span class="nv">total</span><span class="p">)]</span>
</span><span class='line'>  <span class="p">[</span><span class="nv">Customer</span> <span class="p">(</span><span class="nb">= </span><span class="nv">?id</span> <span class="nv">id</span><span class="p">)])</span>
</span></code></pre></td></tr></table></div></figure>


<p>This queries the working memory to simply find customer and orders with the same id. (See the <a href="https://github.com/rbrush/clara-rules/wiki/Guide">Clara documentation</a> for details on use.)</p>

<p>Clara makes extensive use of Clojure&rsquo;s <code>group-by</code> function to group collections of facts by matching keys. After tuning my algorithm, I discovered that some benchmarks were spending the bulk of their time in <code>group-by</code>. The <code>group-by</code> implementation can be found in <a href="https://github.com/clojure/clojure/blob/master/src/clj/clojure/core.clj">the Clojure source</a>, but here it is for convenience:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='clj'><span class='line'><span class="p">(</span><span class="kd">defn </span><span class="nv">group-by</span>
</span><span class='line'>  <span class="s">&quot;Returns a map of the elements of coll keyed by the result of</span>
</span><span class='line'><span class="s">  f on each element. The value at each key will be a vector of the</span>
</span><span class='line'><span class="s">  corresponding elements, in the order they appeared in coll.&quot;</span>
</span><span class='line'>  <span class="p">{</span><span class="ss">:added</span> <span class="s">&quot;1.2&quot;</span>
</span><span class='line'>   <span class="ss">:static</span> <span class="nv">true</span><span class="p">}</span>
</span><span class='line'>  <span class="p">[</span><span class="nv">f</span> <span class="nv">coll</span><span class="p">]</span>
</span><span class='line'>  <span class="p">(</span><span class="nf">persistent!</span>
</span><span class='line'>   <span class="p">(</span><span class="nf">reduce</span>
</span><span class='line'>    <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">ret</span> <span class="nv">x</span><span class="p">]</span>
</span><span class='line'>      <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">k</span> <span class="p">(</span><span class="nf">f</span> <span class="nv">x</span><span class="p">)]</span>
</span><span class='line'>        <span class="p">(</span><span class="nf">assoc!</span> <span class="nv">ret</span> <span class="nv">k</span> <span class="p">(</span><span class="nb">conj </span><span class="p">(</span><span class="nb">get </span><span class="nv">ret</span> <span class="nv">k</span> <span class="p">[])</span> <span class="nv">x</span><span class="p">))))</span>
</span><span class='line'>    <span class="p">(</span><span class="nf">transient</span> <span class="p">{})</span> <span class="nv">coll</span><span class="p">)))</span>
</span></code></pre></td></tr></table></div></figure>


<p>Notice the use of Clojure transients, which are mutable structures designed to be used locally for efficiency. Clojure takes a pragmatic step here. The goal is to keep our systems easy to reason about, and we can achieve that if no external observer can detect mutability. <code>group-by</code> is a pure function working with immutable structures for all observers, but gains performance by using transients internally.</p>

<p>The trouble I ran into with my benchmarks is that I had many items mapping to the same key. Notice that Clojure&rsquo;s group-by uses a transient map, but that map contains non-transient vectors. So the performance bottleneck arose because this group-by function wasn&rsquo;t &ldquo;transient enough&rdquo; for my particular data.</p>

<p>I worked around this by writing an alternate group-by that better fit my needs. Its internals are hideous but are the result of profiling a couple implementations:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class='clj'><span class='line'><span class="p">(</span><span class="kd">defn </span><span class="nv">tuned-group-by</span>
</span><span class='line'>  <span class="s">&quot;Equivalent of the built-in group-by, but tuned for when </span>
</span><span class='line'><span class="s">   there are many values per key.&quot;</span>
</span><span class='line'>  <span class="p">[</span><span class="nv">f</span> <span class="nv">coll</span><span class="p">]</span>
</span><span class='line'>  <span class="p">(</span><span class="nf">-&gt;&gt;</span> <span class="nv">coll</span>
</span><span class='line'>       <span class="c1">;; Create a mutable map of transient vectors.</span>
</span><span class='line'>       <span class="p">(</span><span class="nb">reduce </span><span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nb">map </span><span class="nv">value</span><span class="p">]</span>
</span><span class='line'>                 <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">k</span> <span class="p">(</span><span class="nf">f</span> <span class="nv">value</span><span class="p">)</span>
</span><span class='line'>                       <span class="nv">items</span> <span class="p">(</span><span class="nb">or </span><span class="p">(</span><span class="nf">.get</span> <span class="o">^</span><span class="nv">java.util.HashMap</span> <span class="nb">map </span><span class="nv">k</span><span class="p">)</span>
</span><span class='line'>                                 <span class="p">(</span><span class="nf">transient</span> <span class="p">[]))]</span>
</span><span class='line'>                   <span class="p">(</span><span class="nf">.put</span> <span class="o">^</span><span class="nv">java.util.HashMap</span> <span class="nb">map </span><span class="nv">k</span> <span class="p">(</span><span class="nf">conj!</span> <span class="nv">items</span> <span class="nv">value</span><span class="p">)))</span>
</span><span class='line'>                 <span class="nv">map</span><span class="p">)</span>
</span><span class='line'>               <span class="p">(</span><span class="nf">java.util.HashMap.</span><span class="p">))</span>
</span><span class='line'>      <span class="c1">;; Make the vectors immutable into a transient map.</span>
</span><span class='line'>      <span class="p">(</span><span class="nb">reduce </span><span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nb">map </span><span class="p">[</span><span class="nb">key </span><span class="nv">value</span><span class="p">]]</span>
</span><span class='line'>                  <span class="p">(</span><span class="nf">assoc!</span> <span class="nb">map key </span><span class="p">(</span><span class="nf">persistent!</span> <span class="nv">value</span><span class="p">)))</span>
</span><span class='line'>                <span class="p">(</span><span class="nf">transient</span> <span class="p">{}))</span>
</span><span class='line'>      <span class="c1">;; Make the map itself immutable.</span>
</span><span class='line'>      <span class="p">(</span><span class="nf">persistent!</span><span class="p">)))</span>
</span></code></pre></td></tr></table></div></figure>


<p>This is more efficient when there are many items that map to the same key in the returned map, since it uses transient values. (The Java HashMap turned out to be the fastest option to build the result here, but it never escapes this function.) This optimization cut some benchmark times in half. Combined with a number of smaller tweaks, this brought most of Clara&rsquo;s use cases inline with Drools performance. For other use cases Clara significantly outperforms Drools, but we&rsquo;ll get to those later.</p>

<p>My <code>tuned-group-by</code> function is faster than Clojure&rsquo;s <code>group-by</code> for some inputs and slower for others. But this misses a bigger advantage: <strong><em>Clojure&rsquo;s philosophy of separating functions and data made swapping implementations trivial, allowing users to pick the right ones for their specific needs.</em></strong> This isn&rsquo;t so easily done if functions are strongly tied to the data they work with, which is an easy pitfall of object-oriented programming.</p>

<h3>Referential Transparency Breeds Serendipity</h3>

<p>Writing functional code tends to create pleasant surprises. We come across significant advantages that wouldn&rsquo;t be possible with a different approach. Considering the following Clara example and it&rsquo;s Drools equivalent:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='clj'><span class='line'><span class="p">(</span><span class="kd">ns </span><span class="nv">clara.benchmark.visit-order-same-day</span>
</span><span class='line'>  <span class="p">(</span><span class="ss">:require</span> <span class="p">[</span><span class="nv">clara.rules</span> <span class="ss">:refer</span> <span class="ss">:all</span><span class="p">]</span>
</span><span class='line'>            <span class="p">[</span><span class="nv">clj-time.coerce</span> <span class="ss">:as</span> <span class="nv">coerce</span><span class="p">])</span>
</span><span class='line'>  <span class="p">(</span><span class="ss">:import</span> <span class="p">[</span><span class="nv">clara.benchmark.beans</span> <span class="nv">Order</span> <span class="nv">Visit</span><span class="p">]))</span>
</span><span class='line'>
</span><span class='line'><span class="p">(</span><span class="nf">defquery</span> <span class="nv">same-day-visit</span>
</span><span class='line'>   <span class="s">&quot;Queries orders that occurred the same day as a visit.&quot;</span>
</span><span class='line'>   <span class="p">[]</span>
</span><span class='line'>   <span class="p">[</span><span class="nv">Order</span> <span class="p">(</span><span class="nb">= </span><span class="nv">?id</span> <span class="nv">customerId</span><span class="p">)</span> <span class="p">(</span><span class="nb">= </span><span class="nv">?day</span> <span class="p">(</span><span class="nf">coerce/to-local-date</span> <span class="nv">time</span><span class="p">))]</span>
</span><span class='line'>   <span class="p">[</span><span class="nv">Visit</span> <span class="p">(</span><span class="nb">= </span><span class="nv">?id</span> <span class="nv">customerId</span><span class="p">)</span> <span class="p">(</span><span class="nb">= </span><span class="nv">?day</span> <span class="p">(</span><span class="nf">coerce/to-local-date</span> <span class="nv">time</span><span class="p">))])</span>
</span></code></pre></td></tr></table></div></figure>


<p>Drools equivalent:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kn">package</span> <span class="n">clara</span><span class="o">.</span><span class="na">benchmark</span><span class="o">.</span><span class="na">drools</span><span class="o">.</span><span class="na">visit_order_same_day</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'><span class="kn">import</span> <span class="nn">clara.benchmark.beans.Order</span><span class="o">;</span>
</span><span class='line'><span class="kn">import</span> <span class="nn">clara.benchmark.beans.Visit</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'><span class="kn">import</span> <span class="nn">org.joda.time.DateTime</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'><span class="n">query</span> <span class="s">&quot;same_day_visit&quot;</span>
</span><span class='line'>
</span><span class='line'>   <span class="n">Order</span><span class="o">(</span><span class="n">$id</span> <span class="o">:</span> <span class="n">customerId</span><span class="o">,</span> <span class="n">$day</span> <span class="o">:</span> <span class="n">time</span><span class="o">.</span><span class="na">toLocalDate</span><span class="o">())</span>
</span><span class='line'>   <span class="n">Visit</span><span class="o">(</span><span class="n">$id</span> <span class="o">==</span> <span class="n">customerId</span><span class="o">,</span> <span class="n">$day</span> <span class="o">==</span> <span class="n">time</span><span class="o">.</span><span class="na">toLocalDate</span><span class="o">())</span>
</span><span class='line'>
</span><span class='line'><span class="n">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>These rules simply identify things happening on the same day. Yet there is a big difference: Drools does an O(n<sup>2</sup>) Cartesian join where Clara does an O(n*log<sub>32</sub>n) indexed join of each item. Therefore Clara becomes dramatically faster than Drools for large inputs in this case. Also notice how Clara cleanly integrates with Clojure&rsquo;s syntax, as opposed to embedding multiple syntaxes into a file, since it treats <a href="http://www.toomuchcode.org/blog/2013/09/24/rules-as-a-control-structure/">rules as a control structure</a>.</p>

<p>This is possible because of Clojure&rsquo;s emphasis on pure, referentially transparent functions. Since we can replace the function call with its result, we can build an index of that result. The outcome is a significantly more efficient system for this class of problem.</p>

<p>Along the same lines, rule engines facilities to reason over sets of facts can be implemented more efficiently under these constraints. Clara&rsquo;s equivalent of Jess and Drools <em>accumulators</em> simply compile into Clojure <a href="http://clojure.org/reducers">reducers</a>, making them more efficient than the alternatives by simply tapping into that feature.</p>

<p>These advantages arise often: we can defer computation to efficient batch operations. We can transparently spread work across threads without dealing with lock-based concurrency. We can memoize functions or build efficient caches based on fast reference comparison. Importantly, when starting a problem it&rsquo;s not always obvious how these advantages will arise, but these techniques provide an opportunity for great optimizations at the macro level. David Nolen&rsquo;s <a href="http://swannodette.github.io/2013/12/17/the-future-of-javascript-mvcs/">work on Om</a> is a dramatic example of this in action.</p>

<h2>The Trouble with Benchmarks</h2>

<p>X is faster than Y makes for a great incendiary headline on Hacker News, but it doesn&rsquo;t really make sense. X may be faster than Y for workload Z with trade offs A, B, and C&hellip;but for some reason those headlines don&rsquo;t get as many upvotes.</p>

<p>Benchmarks are informative and an important tool to improve our system. But they aren&rsquo;t a real measure of a system&rsquo;s quality or potential. A better measure is how easily a system can be understood, adapted, and expanded. If we can <em>understand</em> the nature of a problem, performance or otherwise, we can usually fix it. Clojure simply provides better mechanisms to understand and improve our systems than other languages I&rsquo;ve used.</p>

<p>In short, the trouble with benchmarks is they encourage treating symptoms rather the than the explosion of complexity that limits what we can build.</p>

<h2>Clara&rsquo;s Future</h2>

<p>All optimizations discussed here are in master and will be released in Clara 0.6.0 this summer. You can see some current comparisons with Drools in the <a href="https://github.com/rbrush/clara-benchmark">clara-benchmark project</a>. There are still opportunities for improvement in Clara, being a relatively new system. Probably the next significant optimization is greater laziness, <a href="https://github.com/rbrush/clara-rules/issues/58">which we&rsquo;re tracking here</a>.</p>

<p>Updates will be posted here and on <a href="https://twitter.com/ryanbrush">my twitter feed</a>. I&rsquo;ll also be discussing modern approaches to expert systems, including Clara, at two conferences over the next few months: <a href="http://www.midwest.io">Midwest.io</a> in July and <a href="https://thestrangeloop.com">strangeloop</a> in September.</p>

<p>Discussion of this post can be <a href="https://news.ycombinator.com/item?id=7898448">done on Hacker News</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Clara 0.5 Released]]></title>
    <link href="http://www.toomuchcode.org/blog/2014/05/17/clara-0-dot-5-released/"/>
    <updated>2014-05-17T11:52:07-05:00</updated>
    <id>http://www.toomuchcode.org/blog/2014/05/17/clara-0-dot-5-released</id>
    <content type="html"><![CDATA[<p>Clara 0.5 has been released! This is mostly a big fix release with some usability improvements. See the <a href="https://github.com/rbrush/clara-rules/blob/master/CHANGELOG.md">changelog</a> and the <a href="https://github.com/rbrush/clara-rules">github page</a> for usage information.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Clara 0.4 Released]]></title>
    <link href="http://www.toomuchcode.org/blog/2014/02/06/clara-0-dot-4-released/"/>
    <updated>2014-02-06T21:32:38-06:00</updated>
    <id>http://www.toomuchcode.org/blog/2014/02/06/clara-0-dot-4-released</id>
    <content type="html"><![CDATA[<p>Clara 0.4 has been released, and is available on Clojars! See the <a href="https://github.com/rbrush/clara-rules">github page</a> for usage information. I wrote about the significant features in the <a href="http://www.toomuchcode.org/blog/2014/01/19/rules-as-data/">Rules as Data</a> post.</p>

<p>The <a href="https://groups.google.com/forum/#!topic/clojure/bvs9zQMDpNg">release announcement</a> is in the Clojure Google Group.</p>

<p>This release puts Clara on a strong footing, and I&rsquo;m looking forward to playing with the new rules-as-data features.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rules as Data]]></title>
    <link href="http://www.toomuchcode.org/blog/2014/01/19/rules-as-data/"/>
    <updated>2014-01-19T12:44:40-06:00</updated>
    <id>http://www.toomuchcode.org/blog/2014/01/19/rules-as-data</id>
    <content type="html"><![CDATA[This started as a topic for a&nbsp;<a href="http://www.meetup.com/lamba-lounge-kc/" target="_blank">Lambda Lounge</a>&nbsp;meetup but seems worth sharing broadly.<br />I&#8217;ve posted previously about treating <a href="http://www.toomuchcode.org/2013/09/rules-as-control-structure.html" target="_blank">rules as a control structure</a>, but for <a href="https://github.com/rbrush/clara-rules" target="_blank">Clara 0.4</a> rules are now first-class data structures with well-defined schema. &nbsp;The simple <i>defrule</i>&nbsp;syntax is preserved but the macro now produces a data structure that is used everywhere else. For example, the following code:<br />

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="nf">defrule</span> <span class="nv">date-too-early</span>
</span><span class='line'>  <span class="s">&quot;We can&#39;t schedule something too early.&quot;</span>
</span><span class='line'>  <span class="p">[</span><span class="nv">WorkOrder</span> <span class="p">(</span><span class="nb">&lt; </span><span class="p">(</span><span class="nf">weeks-until</span> <span class="nv">date</span><span class="p">)</span> <span class="mi">2</span><span class="p">)]</span>
</span><span class='line'>  <span class="nv">=&gt;</span>
</span><span class='line'>  <span class="p">(</span><span class="nf">insert!</span> <span class="p">(</span><span class="nf">-&gt;ApprovalRequired</span> <span class="ss">:timeline</span> <span class="s">&quot;Date is too early&quot;</span><span class="p">)))</span>
</span></code></pre></td></tr></table></div></figure>

Defines a var containing this structure:<br />
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">{</span><span class="ss">:doc</span> <span class="s">&quot;We can&#39;t schedule something too early.&quot;</span>,
</span><span class='line'> <span class="ss">:name</span> <span class="s">&quot;date-too-early&quot;</span>,
</span><span class='line'> <span class="ss">:lhs</span>
</span><span class='line'> <span class="p">[{</span><span class="ss">:constraints</span> <span class="p">[(</span><span class="nb">&lt; </span><span class="p">(</span><span class="nf">llkc.example/weeks-until</span> <span class="nv">date</span><span class="p">)</span> <span class="mi">2</span><span class="p">)]</span>,
</span><span class='line'>   <span class="ss">:type</span> <span class="nv">llkc.example.WorkOrder</span><span class="p">}]</span>,
</span><span class='line'> <span class="ss">:rhs</span>
</span><span class='line'> <span class="p">(</span><span class="nf">clara.rules/insert!</span>
</span><span class='line'>  <span class="p">(</span><span class="nf">llkc.example/-&gt;ApprovalRequired</span> <span class="ss">:timeline</span> <span class="s">&quot;Date is too early&quot;</span><span class="p">))}</span>
</span></code></pre></td></tr></table></div></figure>

The rule structure itself is <a href="https://github.com/rbrush/clara-rules/blob/master/src/main/clojure/clara/rules/schema.clj#L50" target="_blank">defined in Clara&#8217;s schema</a>, and simply stored in the var with the rule&#8217;s name.<br /><br />So, now that rules are data, we open the door to tooling to explore and manipulate them. For instance, we can visualize the relationship between rules. Here is a visualization of the <a href="https://github.com/rbrush/presentations/blob/master/llkc-2014-jan/src/llkc/example.clj" target="_blank">rules used for the meetup</a>. I arbitrarily chose shapes to distinguish the different types of data:<br /><div class="separator" style="clear: both; text-align: center;"><br /></div><div class="separator" style="clear: both; text-align: center;"><a href="http://www.toomuchcode.org/images/rules-as-data-logic.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://www.toomuchcode.org/images/rules-as-data-logic-small.png" /></a></div><br /><br />This image is generated by running the following <a href="https://github.com/rbrush/clara-rules/blob/master/src/main/clojure/clara/tools/viz.clj" target="_blank">function from clara.tools.viz</a> against <a href="https://github.com/rbrush/presentations/blob/master/llkc-2014-jan/src/llkc/example.clj" target="_blank">the example used at the meetup</a>:<br />

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="nf">viz/show-logic!</span> <span class="ss">&#39;llkc.example</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>

That function simply scans each rule in the given namespace, reads individual conditions from the rule data structure, and wires them up. The graph itself is rendered with GraphViz.<br /><br />Since all rules of data, they can be filtered or manipulated like any Clojure data structure. So here we take our set of rules and only display those that handle logic for validation errors:<br />

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="nf">viz/show-logic!</span>
</span><span class='line'>  <span class="p">(</span><span class="nb">filter </span><span class="o">#</span><span class="p">(</span><span class="nf">viz/inserts?</span> <span class="nv">%</span> <span class="nv">ValidationError</span><span class="p">)</span>
</span><span class='line'>    <span class="p">(</span><span class="nf">viz/get-productions</span> <span class="p">[</span><span class="ss">&#39;llkc.example</span><span class="p">])))</span>
</span></code></pre></td></tr></table></div></figure>

In this example there is only one rule that does validation, so the resulting image looks like this:<br /><div class="separator" style="clear: both; text-align: center;"><a href="http://www.toomuchcode.org/images/rules-as-data-valid.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://www.toomuchcode.org/images/rules-as-data-valid.png" height="169" width="320" /></a></div><br /><h2>Rule engine as an API</h2>The rules-as-data model creates another significant advantage: we have decoupled the DSL-style syntax from the rule engine itself. Clara users can now create rules from arbitrary sources, such as a specialized syntax, an external database, or domain-specific file format. (Think <a href="https://github.com/Engelberg/instaparse" target="_blank">instaparse</a> tied to rule generation.) Clara is evolving into a general Rete engine, with its &#8220;defrule&#8221; syntax being just one way to use it.<br /><br />So far I&#8217;ve written only simple, GraphViz-based visualizations but we can expose these with more sophisticated UIs. Projecting such visualizations onto, say, a D3-based graph could provide a rich, interactive way of exploring logic.<br /><br />At this point, <a href="https://github.com/rbrush/clara-rules" target="_blank">Clara 0.4 is available as snapshot builds</a>. I expect to do a release in February, pending some cleanup and enhancements to ClojureScript support. I&#8217;ll post updates on my twitter feed, <a href="https://twitter.com/ryanbrush" target="_blank">@ryanbrush</a>.]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Crossing the (data) streams&#58; scalable realtime processing with rules]]></title>
    <link href="http://www.toomuchcode.org/blog/2013/11/09/crossing-the-data-streams-scalable-realtime-processing-with-rules/"/>
    <updated>2013-11-09T08:31:17-06:00</updated>
    <id>http://www.toomuchcode.org/blog/2013/11/09/crossing-the-data-streams-scalable-realtime-processing-with-rules</id>
    <content type="html"><![CDATA[Pipe-and-filter architectures are among the most successful design patterns ever. They dominate data ingestion and processing today, and give 1970&#8217;s hackers yet another chance to remind us how they thought of everything years ago.<br /><br />Unfortunately modern variations of this can run into an ugly problem: what are the semantics of a &#8220;join&#8221; operation between multiple infinite streams of data? Popular systems like Storm <a href="https://github.com/nathanmarz/storm/wiki/Common-patterns" target="_blank">point out this ambiguity</a>, <a href="http://samza.incubator.apache.org/learn/documentation/0.7.0/container/state-management.html" target="_blank">as does Samza</a>. Both provide primitives to support correlation of events between streams, but the higher-level semantics of a join are punted to the user.

<br /><br />This is fine for such systems providing infrastructure, but is a troublesome model of our applications: if we can&#8217;t define clear and compelling semantics for a key part of our processing model, we might be using the wrong model. Projects like Storm offer an excellent infrastructure, but this ambiguity implies that many problems could be solved with a higher-level abstraction.<br /><br />The challenge with user-defined join semantics is it comes with baggage: maintaining state, structuring it, and recovering state after failure scenarios are challenging problems. It also makes the behavior of the system harder to understand. Since each join can have slightly different behavior, we need to look closely to see what&#8217;s going on. A better approach is needed. A set of simple yet flexible join operators would be ideal &#8211; so how do we get there?<br /><br />

<blockquote class="tr_bq"><div style="text-align: center;"><span style="font-size: large;"><i>If we can&#8217;t define clear and compelling semantics for a key part of our processing model, we might be using the wrong model.</i></span></div></blockquote>

We might consider CEP-style systems such as Esper and Drools Fusion, which have been tackling declarative-style joins for years. But such systems don&#8217;t offer the scalability or processing guarantees of Storm, and they use limited languages that aren&#8217;t always expressive enough for sophisticated logic.<br /><br />We need a data processing model with well-defined, declarative joins while supporting rich application logic. There are lots of options here, but here I&#8217;ll focus on one: suppose we could make&nbsp;<a href="http://www.toomuchcode.org/2013/09/rules-as-control-structure.html" target="_blank">rules as a control structure</a>&nbsp;scale linearly across a cluster, letting the rules engine distribute join operations. Let&#8217;s look at an experiment of making <a href="https://github.com/rbrush/clara-rules" target="_blank">Clara, a Clojure-based rules engine</a>, distribute its working memory and processing across a Storm cluster, with all of the scalability and processing guarantees of the underlying system.<br /><br /><h3>Forward-chaining rules on Storm</h3>Imagine a variant of the <a href="http://en.wikipedia.org/wiki/Rete_algorithm" target="_blank">Rete algorithm</a> implemented with some simple constraints:<br /><br />First, each condition in a rule can be evaluated independently, so incoming data can be spread across an arbitrary number of processes and match rule conditions appropriately.<br /><br />Second, aggregations over matched facts follow a map-and-reduce style pattern &#8211; where the map and partial reductions of aggregated facts can be done in parallel across machines.<br /><br />Finally, &#8220;joins&#8221; of aggregations or individual facts are always hash-based. So joins can be efficiently achieved by sending matched facts to the same node via their hash values.<br /><br />The result is our Storm topology looks something like this:<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://4.bp.blogspot.com/-f_frwIKZjko/Un0YiMW56jI/AAAAAAAAAIE/5GotL58ac28/s1600/clara-storm-diagram.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="210" src="http://4.bp.blogspot.com/-f_frwIKZjko/Un0YiMW56jI/AAAAAAAAAIE/5GotL58ac28/s320/clara-storm-diagram.png" width="320" /></a></div><div class="separator" style="clear: both; text-align: center;"><span style="text-align: left;"><br /></span></div><div class="separator" style="clear: both; text-align: justify;"><span style="text-align: left;">Let&#8217;s consider a simple example. Suppose we have feeds of temperature readings from multiple locations in some facility, and we want to take action in those locations should our readings exceed a threshold.</span></div><br />Each temperature reading has a logical timestamp, so since our logic is interested in the &#8220;newest&#8221; reading, we use a <a href="https://github.com/rbrush/clara-rules/wiki/Accumulators" target="_blank">Clara accumulator</a> that selects the item with the newest timestamp:

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="k">def </span><span class="nv">newest-temp</span> <span class="p">(</span><span class="nf">acc/max</span> <span class="ss">:timestamp</span> <span class="ss">:returns-fact</span> <span class="nv">true</span><span class="p">))</span>
</span></code></pre></td></tr></table></div></figure>

We then use it in a rule that processes all our readings for a location and preserves the newest:

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="nf">defrule</span> <span class="nv">get-current-temperature</span>
</span><span class='line'>  <span class="s">&quot;Get the current temperature at a location by simply </span>
</span><span class='line'><span class="s">   looking at the newest reading.&quot;</span>
</span><span class='line'>  <span class="p">[</span><span class="nv">?current-temp</span> <span class="nv">&lt;-</span> <span class="nv">newest-temp</span> <span class="ss">:from</span> <span class="p">[</span><span class="nv">TemperatureReading</span> <span class="p">(</span><span class="nb">== </span><span class="nv">?location</span> <span class="nv">location</span><span class="p">)]]</span>
</span><span class='line'>  <span class="nv">=&gt;</span>
</span><span class='line'>  <span class="p">(</span><span class="nf">insert!</span> <span class="p">(</span><span class="nf">-&gt;CurrentTemperature</span> <span class="p">(</span><span class="ss">:value</span> <span class="nv">?current-temp</span><span class="p">)</span> <span class="nv">?location</span><span class="p">)))</span>
</span></code></pre></td></tr></table></div></figure>

Note that accumulators preserve minimal state and apply changes incrementally. In this case we keep only the current temperature based on timestamp; lower values are simply discarded, so we can deal with an infinite stream. &nbsp;Also, this example keeps the maximum, but we could easily accumulate some other value, such as a time-weighted histogram of temperatures to we&#8217;re robust to outliers. Any fact that doesn&#8217;t match a rule is simply discarded, incurring no further cost.<br /><br />Now that we have the current temperature for each location, we want to back off our devices in those locations if a threshold is exceeded. We can write this as a simple rule as well:

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="nf">defrule</span> <span class="nv">reduce-device-speed</span>
</span><span class='line'>  <span class="s">&quot;Reduce the speed of all devices in a location that has a high temperature.&quot;</span>
</span><span class='line'>  <span class="p">[</span><span class="nv">CurrentTemperature</span> <span class="p">(</span><span class="nb">&gt; </span><span class="nv">value</span> <span class="nv">high-threshold</span><span class="p">)</span>
</span><span class='line'>                      <span class="p">(</span><span class="nb">= </span><span class="nv">?location-id</span> <span class="nv">location</span><span class="p">)]</span>
</span><span class='line'>  <span class="c1">;; Find all Device records in the location, and bind them to the ?device variable.</span>
</span><span class='line'>  <span class="p">[</span><span class="nv">?device</span> <span class="nv">&lt;-</span> <span class="nv">Device</span> <span class="p">(</span><span class="nb">= </span><span class="nv">?location-id</span> <span class="nv">location</span><span class="p">)]</span>
</span><span class='line'>  <span class="nv">=&gt;</span>
</span><span class='line'>  <span class="p">(</span><span class="nf">reduce-speed!</span> <span class="nv">?device</span><span class="p">))</span>
</span></code></pre></td></tr></table></div></figure>

This first condition matches current temperatures that exceed the threshold, and binds it the ?location-id variable. &nbsp;The second condition finds all devices with a matching location, and binds them to the ?device variable. &nbsp;This is then visible on the right-hand side of the rule, where we can take action.<br /><br />This is effectively performing a join between temperatures that exceeded a threshold at a given location and devices in that same location. When running over Storm, this rule wish hash Device and CurrentTemperature facts and send them to the same processing using a hash value. This is done using Storm&#8217;s group-by field functionality over a data stream that connects each bolt instance together.<br /><br />All state for the join operations are managed internally by Clara&#8217;s engine. Accumulators like the example here compute in a rolling fashion, merging new data together, retracting previously accumulated values, and inserting new ones. Combined with rule engine-style truth maintenance, developers can simply declare their logic and let the engine maintain state and consistency.<br /><br /><h3>Integration with Processing Topologies</h3>The <a href="https://github.com/rbrush/clara-examples/blob/master/src/main/clojure/clara/examples/sensors.clj" target="_blank">rules used in this example are here</a>, and are run with the <a href="https://github.com/rbrush/clara-examples/blob/master/src/main/clojure/clara/examples/storm.clj" target="_blank">Storm launching code here</a>. There is also a draft <a href="https://github.com/rbrush/clara-storm/blob/master/src/main/java/clara/storm/RuleBolts.java" target="_blank">Java API to attach rules to a topology</a>. Note that our approach is to simply attach to a Storm topology defined via a provided TopologyBuilders, so users can pre-process or perform other logic in their topology, and route data as appropriate into the distributed rule engine. Also, these examples use Clojure records, but they can work equally well with Java objects, including ones generated by Thrift, Avro, or Protocol Buffers.<br /><br /><h3>Current State</h3>A prototype of rules over Storm is in the <a href="https://github.com/rbrush/clara-storm" target="_blank">clara-storm project</a>. It also includes the abilities to run queries across the rule engine&#8217;s working memory, using Storm&#8217;s Distributed RPC mechanism. A handful of things need to come together to make this production ready, inluding:<br /><br /><ul><li>I&#8217;d like input and suggestions from members of the Storm community. This topology layout isn&#8217;t an idiomatic use of Storm, so we need to ensure this won&#8217;t run into problems as we scale. &nbsp;(This is one of the reasons I&#8217;m posting this now.)</li><li>The <a href="https://github.com/rbrush/clara-rules/issues/16" target="_blank">ability to persist Clara&#8217;s working memory</a> to recover from machine failures. This will probably take the form of writing state changes for each rule node to reliable write-ahead log, with Kafka being a good storage mechanism.</li><li>Optimizations ranging from efficient serialization to doing partial aggregations prior to sharing state between bolts are needed.</li><li>Consider temporal operators in Clara. Accumulators have worked well to this point but may run into limits.</li><li>Testing at scale!</li></ul><div>The biggest takeaway is how technologies like Storm and Clojure provide an opportunity to express computation with higher-level abstractions. Things like <a href="https://blog.twitter.com/2013/streaming-mapreduce-with-summingbird" target="_blank">SummingBird</a>&nbsp;(and Cascalog 2.0?) offer ways to query data streams. These could be complemented by support for forward-chaining rules for problems easily expressed that way.</div>]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rules as a Control Structure]]></title>
    <link href="http://www.toomuchcode.org/blog/2013/09/24/rules-as-a-control-structure/"/>
    <updated>2013-09-24T06:47:12-05:00</updated>
    <id>http://www.toomuchcode.org/blog/2013/09/24/rules-as-a-control-structure</id>
    <content type="html"><![CDATA[Rule engines seem to draw love-or-hate reactions. On one hand they offer a simple way to manage lots of arbitrary, complex, frequently-changing business logic. On the other, their simplicity often comes with limitations, and edge cases pop up that can&#8217;t be elegantly solved in the confines of rules. There are few things more frustrating than a tool meant to help you solve problems actually creates them.<br /><br />The tragedy is that excellent ideas for modeling logic with rules have been hijacked by a myth: that it&#8217;s &nbsp;possible to <i>write code</i>&nbsp;&#8211; to unambiguously define logic in a textual form &#8211;<i>&nbsp;without actually writing code.</i>&nbsp;We see authoring tools generating rules in limited languages (or XML!), making the case that domain experts can author logic without development expertise. The shortage of good developers makes this tremendously appealing, and this demand has drawn supply.

<br /><br />If you have a limited problem space satisfied by such tools, then great. But problems remain:<br /> <br />

<ul>
<li>Limited problem spaces often don&#8217;t stay limited.</li>
<li>Many problems involving arbitrary domain knowledge are best solved with rules when we can, but require the ability to integrate with a richer programming environment when we must.</li>
</ul>

<div>So how do we approach this? We need to stop thinking of rule engines as external systems that create artificial barriers between our logic, but as first-class constructs seamlessly integrated in the host language. &nbsp;In other words, rules engines are best viewed as an <i>alternate control structure</i>, suited to the business problem at hand.<br /><br />Clojure is uniquely positioned to tackle this problem. Macros make sophisticated alternate control structures possible, Clojure&#8217;s rich data structures make it suitable for solving many classes of problems, and its JVM integration makes it easy to plug into many systems. This is the idea behind <a href="https://github.com/rbrush/clara-rules">Clara</a>, a forward-chaining rules implementation in pure Clojure.</div><div><br /></div><div>Here&#8217;s an example from the <a href="https://github.com/rbrush/clara-rules/wiki/Introduction">Clara documentation</a>. &nbsp;In a retail setting with many arbitrary frequently promotions, we might author them like this:
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="nf">defrule</span> <span class="nv">free-lunch-with-gizmo</span>
</span><span class='line'>  <span class="s">&quot;Anyone who purchases a gizmo gets a free lunch.&quot;</span>
</span><span class='line'>  <span class="p">[</span><span class="nv">Purchase</span> <span class="p">(</span><span class="nb">= </span><span class="nv">item</span> <span class="ss">:gizmo</span><span class="p">)]</span>
</span><span class='line'>  <span class="nv">=&gt;</span>
</span><span class='line'>  <span class="p">(</span><span class="nf">insert!</span> <span class="p">(</span><span class="nf">-&gt;Promotion</span> <span class="ss">:free-lunch-with-gizmo</span> <span class="ss">:lunch</span><span class="p">)))</span>
</span></code></pre></td></tr></table></div></figure>

And create a query to retrieve promotions:
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="nf">defquery</span> <span class="nv">get-promotions</span>
</span><span class='line'>  <span class="s">&quot;Query to find promotions for the purchase.&quot;</span>
</span><span class='line'>  <span class="p">[]</span>
</span><span class='line'>  <span class="p">[</span><span class="nv">?promotion</span> <span class="nv">&lt;-</span> <span class="nv">Promotion</span><span class="p">])</span>
</span></code></pre></td></tr></table></div></figure>

All of this is usable with idiomatic Clojure code:
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="nb">-&gt; </span><span class="p">(</span><span class="nf">mk-session</span> <span class="ss">&#39;clara.examples.shopping</span><span class="p">)</span> <span class="c1">; Load the rules.</span>
</span><span class='line'>    <span class="p">(</span><span class="nf">insert</span> <span class="p">(</span><span class="nf">-&gt;Customer</span> <span class="ss">:vip</span><span class="p">)</span>
</span><span class='line'>            <span class="p">(</span><span class="nf">-&gt;Order</span> <span class="mi">2013</span> <span class="ss">:march</span> <span class="mi">20</span><span class="p">)</span>
</span><span class='line'>            <span class="p">(</span><span class="nf">-&gt;Purchase</span> <span class="mi">20</span> <span class="ss">:gizmo</span><span class="p">)</span>
</span><span class='line'>            <span class="p">(</span><span class="nf">-&gt;Purchase</span> <span class="mi">120</span> <span class="ss">:widget</span><span class="p">))</span> <span class="c1">; Insert some facts.</span>
</span><span class='line'>    <span class="p">(</span><span class="nf">fire-rules</span><span class="p">)</span>
</span><span class='line'>    <span class="p">(</span><span class="nf">query</span> <span class="nv">get-promotions</span><span class="p">))</span>
</span></code></pre></td></tr></table></div></figure>

The resulting query returns the matching promotions. More sophisticated examples may join multiple facts and query by parameters; see the <a href="https://github.com/rbrush/clara-rules/wiki/Guide">developer guide</a> or the &nbsp;<a href="https://github.com/rbrush/clara-examples">clara-examples project</a> for more.<br /><br />Each rule constraint and action &#8211; the left-hand and right-hand sides &#8211; are simply Clojure expressions that can contain arbitrary logic. We also benefit from other advantages of Clojure. For instance, Clara&#8217;s working memory is an immutable, persistent data structure. Some of the advantages of that may come in a later post.<br /><h2>Rules by domain experts</h2><div>So we&#8217;ve broken down some traditional barriers in rule engines, but it seems like this approach comes with a downside: by making rules a control structure in high-level languages, are we excluding non-programmer domain experts from authoring them?<br /><br />We can expand our rule authoring audience in a couple ways:<br /><br />

<div>
<ol>
<li>Encapsulate rules into their own files editable by domain experts, yet compiled into the rest of the system. An audience savvy enough to work with, say, Drools can understand the above examples and many others.</li>
<li>Generate rules from higher-level, domain-specific macros. Business logic could be modeled in a higher-level declarative structure that creates the rules at compile time. Generating rules is actually simpler than most logic generation, since rule ordering and truth maintenance are handled by the engine itself.</li>
<li>Tooling to generate rules directly or indirectly. Like all Lisp code, these rules are also data structures. In fact, they are simpler to work with than an arbitrary s-expression because they offer more structure: a set of facts used by simple constraints resulting in an action, which could also contribute more knowledge to the session&#8217;s working memory.&nbsp;</li></ol>
</div>
<div>Ultimately, all of this results in Clojure code that plugs directly into a rich ecosystem.&nbsp;</div><div><br /></div><div>These options will be fun to explore, but this isn&#8217;t my initial target. Let&#8217;s first create a useful tool for expressing complex logic in Clojure. Hopefully this will become a basis for exploration,&nbsp;borrowing good ideas for expressing business rules and making them available in many environments via the best Lisp available.</div><div><br /></div></div>If this seems promising, check out the <a href="https://github.com/rbrush/clara-rules">Clara project on github</a> for more. I&#8217;ll also post updates on twitter at @ryanbrush.<br /><br />Update: see the <a href="https://groups.google.com/forum/#!topic/clojure/pfeFyZkoRdU">Clojure Google Group</a> for some discussion on this topic.<br /><br />]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[A long time ago, we used to be friends]]></title>
    <link href="http://www.toomuchcode.org/blog/2013/08/18/a-long-time-ago-we-used-to-be-friends/"/>
    <updated>2013-08-18T11:42:45-05:00</updated>
    <id>http://www.toomuchcode.org/blog/2013/08/18/a-long-time-ago-we-used-to-be-friends</id>
    <content type="html"><![CDATA[No one ever intends to let their blogs go dark, but here we are. &nbsp;I&#8217;m planning on dusting off this blog to write about some new personal projects, but for now I thought I&#8217;d link to writing I&#8217;ve done in other venues:

<br /><br />I&#8217;ve written a few posts for <a href="https://engineering.cerner.com/">Cerner&#8217;s Engineering blog</a> as part of my work at Cerner. These include:<br /><ul><li><a href="https://engineering.cerner.com/2013/02/composable-mapreduce-with-hadoop-and-crunch/">Composable MapReduce with Hadoop and Crunch</a></li><li><a href="https://engineering.cerner.com/2013/02/near-real-time-processing-over-hadoop-and-hbase/">Near Real-time Processing Over Hadoop and HBase</a></li><li><a href="https://engineering.cerner.com/2013/07/thinking-in-mapreduce/">Thinking in MapReduce</a></li></ul><div>Some of this content is from talks that I&#8217;ve given at Hadoop World, ApacheCon, and StampedeCon.<br /><br />Some ideas originally posted to this blog have been published in the book <a href="http://www.amazon.com/Things-Every-Programmer-Should-Know/dp/B00CVDXWV8">97 Things Every Programmer Should Know</a>. <br /><br />My latest personal project has been the construction of a <a href="https://github.com/rbrush/clara-rules">forward-chaining rules engine in Clojure</a>. I expect this and related problems to be the emphasis on this blog moving forward.</div>]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Start by embracing your limits]]></title>
    <link href="http://www.toomuchcode.org/blog/2010/11/27/start-by-embracing-your-limits/"/>
    <updated>2010-11-27T11:37:30-06:00</updated>
    <id>http://www.toomuchcode.org/blog/2010/11/27/start-by-embracing-your-limits</id>
    <content type="html"><![CDATA[<div style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; background-color: transparent; font-family: Times; font-size: medium; "><span style="font-size: 11pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">Nothing in human history has offered more promise but has seen as many failures as software.  We’ve all seen moments of greatness, where a program seems like magic &#8211; but such gems are surrounded by minefields of bugs and indecipherable interfaces.</span><br /><span style="font-size: 11pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; "></span><br /><span style="font-size: 11pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">The result of all this is we programmers are often a frustrated bunch. But should we be? After all, what makes us think that as a species we should have the aptitude to create great software?  Our skill sets evolved in an environment that favored those who could hunt boar and find berries &#8211; any capacity to succeed in the abstract world of software is pure, accidental side effect.  Perhaps we should be awed by software’s successes rather than frustrated by its failures.</span><br /><span style="font-size: 11pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; "></span><br /><span style="font-size: 11pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">The good news is we can improve despite our limitations, and it starts with this: accept that we generally have no innate ability to create great systems, and design our practices around that.  It seems like </span><span style="font-size: 11pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">every</span><span style="font-size: 11pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; "> major step forward in software has followed this pattern of embracing our limitations.  For instance, we move to iterative development since we can’t anticipate all variables of a project.  We aggressively unit test because we realize we’re prone to error. Libraries derived from practical experience frequently replace those built by expert groups.   The list goes on.</span><br /><span style="font-size: 11pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; "></span><br /><span style="font-size: 11pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">This type of admission is humbling, but it can also be liberating.  Here’s an example: In years past I would spend hours agonizing over an internal design decision for a system I was building.  I figured if I got it right we could easily bolt on some new feature.  Sometimes I was right, but often times I was not.  My code often was littered with unnecessary structure that only made things more complicated.</span><br /><span style="font-size: 11pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; "></span><br /><span style="font-size: 11pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">Contrast that to today:  I know I can’t anticipate future needs in most cases, so I just apply this simple heuristic: </span><br /><span style="font-size: 11pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; "></span><ol><li style="list-style-type: decimal; font-size: 11pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; "><span style="font-size: 11pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">When in doubt, do the simplest thing possible to solve the problem at hand</span></li><li style="list-style-type: decimal; font-size: 11pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; "><span style="font-size: 11pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">Plan on refactoring later.</span><span style="font-size: 11pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; "> </span></li></ol><span style="font-size: 11pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">The first step frees us from trying to anticipate all future needs &#8211; but this is not quick and dirty cowboy coding.  An essential element of code is to create an understandable and maintainable system.  Don&#8217;t try to code for future needs.  Instead, structure code for present needs so it can be leveraged in the future.  </span><br /><span style="font-size: 11pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; "></span><br /><span style="font-size: 11pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">So how do we do this? A couple things to keep in mind:</span><br /><span style="font-size: 11pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; "></span><ul><li style="list-style-type: disc; font-size: 11pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; "><span style="font-size: 11pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">When in doubt, leave it out. (also known as “You Ain’t Gonna Need It”)</span></li><li style="list-style-type: disc; font-size: 11pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; "><span style="font-size: 11pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">Unit-Testable designs tend to be reusable designs.  Unit tests not only catch bugs that can result from refactoring, but they encourage modularity to enable that refactoring.</span></li><li style="list-style-type: disc; font-size: 11pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; "><span style="font-size: 11pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">Don’t try to design an API independently of an application.  You won’t understand your users’ needs well enough to create a good experience.   Build the API as part of the application to make sure its needs are met, then factor out and generalize.</span></li><li style="list-style-type: disc; font-size: 11pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; "><span style="font-size: 11pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">Group code together that tends to change for similar reasons.  If your Widget class is responsible for rendering its UI </span><span style="font-size: 11pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">and</span><span style="font-size: 11pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; "> writing to the database </span><span style="font-size: 11pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">and</span><span style="font-size: 11pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; "> business logic, you can’t use it anywhere else without significant changes.  High cohesion and loose coupling.</span></li></ul><span style="font-size: 11pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">There are no hard-and-fast rules to building software, but we all need a compass to help guide us through the thousands of micro-decisions we make every time we write code.  Hopefully this post can help build that compass.</span></div>]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Can "Agile in the Large" Succeed?]]></title>
    <link href="http://www.toomuchcode.org/blog/2010/10/18/can-agile-in-the-large-succeed/"/>
    <updated>2010-10-18T21:14:14-05:00</updated>
    <id>http://www.toomuchcode.org/blog/2010/10/18/can-agile-in-the-large-succeed</id>
    <content type="html"><![CDATA[<div    style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; background-   font-family:Times;font-size:medium;color:transparent;"><span class="Apple-style-span"  style="font-family:Arial;"><span class="Apple-style-span" style="white-space: pre-wrap; font-size: -webkit-xxx-large;"><div style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; background-color: transparent; font-family: Times; white-space: normal; font-size: medium; "><span id="internal-source-marker_0.45896949572488666" style="font-size: 11pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">Agile Development isn’t perfect, but it got something right.  Right enough, at least, to gain enough momentum to become a buzzword &#8211; and for consultants to latch on by selling “Agile” to big enterprises.  The result is “Agile in the Large”.</span><br /><span style="font-size: 11pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; "></span><br /><span style="font-size: 11pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">Agile in the Large ranges from the </span><a href="http://www.halfarsedagilemanifesto.org/"><span style="font-size: 11pt; font-family: Arial; color: rgb(0, 0, 153); background-color: transparent; font-weight: normal; font-style: normal; text-decoration: underline; vertical-align: baseline; white-space: pre-wrap; ">Half-Arsed Agile Manifesto</span></a><span style="font-size: 11pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; "> to </span><a href="http://en.wikipedia.org/wiki/Cargo_cult"><span style="font-size: 11pt; font-family: Arial; color: rgb(0, 0, 153); background-color: transparent; font-weight: normal; font-style: normal; text-decoration: underline; vertical-align: baseline; white-space: pre-wrap; ">Cargo Cult</span></a><span style="font-size: 11pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; "> practices.  Too often we simply bolt on a few agile practices without understanding how they provide value.  Adding scrums and iteration reviews to your current process and expecting improvement is like building a runway in your back yard and expecting planes to land.  </span><br /><span style="font-size: 11pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; "></span><br /><span style="font-size: 11pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">Whether it’s labelled agile or not, a cohesive development team works for a couple reasons.  It creates a focused team fully aligned to a common goal. It avoids “Us and Them” mentalities, enabling everyone to adapt to meet the goal. It offers a self-correcting strategy for the thousands of micro-decisions when building software:  It must be testable, “You Ain’t Gonna Need It”, and it creates quick feedback to make sure you’re solving the actual problem.</span><br /><span style="font-size: 11pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; "></span><br /><span style="font-size: 11pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">Agile in the Large is flawed because it often fails to achieve these basic ingredients.  Take Scrum of Scrums, for example.  It tries to coordinate and resolve technical dependencies between teams by having representatives from each team get together and talk through them.  It’s better than nothing, but an emerging system has too much ambiguity: the interaction between components is still being defined, bugs can lead to finger pointing, and the important sense of ownership is lost.  Everyone feels like cogs in a machine rather than someone solving an important problem for a real user.  Our ability to adapt the microdecisions that build great software is lost.</span><br /><span style="font-size: 11pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; "></span><br /><span style="font-size: 11pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">In fact, Agile in the Large seems doomed from the beginning. Once you’re beyond some number of people in a single project, it’s impossible to create that sense of shared ownership and adaptability.  Great software is created by small, dedicated teams.</span><br /><span style="font-size: 11pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; "></span><br /><span style="font-size: 11pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">So, what then? It seems the only way out is to make Agile in the Large more like Agile in the Small.  A team should be working on one and only one project, and include everything necessary for that project to be successful.  How we do that depends on where we are in a project’s maturity curve.</span><br /><span style="font-size: 11pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; "></span><br /><span style="font-size: 11pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: bold; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">New vs. mature systems</span><br /><span style="font-size: 11pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">New development is the most easily handled.  Look at the problems at hand, and make sure the team is equipped to handle them end-to-end.  This new project may have several components, but </span><span style="font-size: 11pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">now is not the time to split those components into their own teams;</span><span style="font-size: 11pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; "> keep a single team aligned to the user’s goals.  After all, if a component isn’t aligned to some user’s goal, what is its value?  Organize around components too early, and team cohesion is lost.</span><br /><span style="font-size: 11pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; "></span><br /><span style="font-size: 11pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">So we are off to a good start, but we need to adjust our strategy as a successful project matures.  You may find parts of your system has value for other uses.  This seems timeless: C first was a successful tool for building Unix, Ruby on Rails was an application before it was a framework, Amazon was an online book store before it was a cloud platform, and so on.  In all of these cases a successful system was built, and then groups arise around the reusable pieces.  Reusable technology will naturally arise from a successful project.  Embrace that, but don’t force it.</span><br /><span style="font-size: 11pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; "></span><br /><span style="font-size: 11pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: bold; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">Open source as a model for reuse</span><span style="font-size: 11pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; "></span><br /><span style="font-size: 11pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">Later in a system’s life we find ourselves consuming many assets from a variety of teams. Now it’s easy to let coordination and communication friction kill our focused project.  Fortunately, the open source world gives us the answer.</span><br /><span style="font-size: 11pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; "></span><br /><span style="font-size: 11pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">Quite simply, needed enhancements to common assets should be written and contributed by consuming teams.  This offers several advantages over logging an enhancement request.  For instance, we reduce deadline haggling and misaligned schedules.  We also reduce the need for frequent status updates and opportunities for miscommunication between teams.</span><br /><span style="font-size: 11pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; "></span><br /><span style="font-size: 11pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">Of course, not all changes to open source projects come in the form of patches.  There should still be a team around the asset in question, responsible for its architecture and fundamental direction.  That team also operates as a gatekeeper, ensuring all patches are properly unit tested, documented, and don’t threaten the integrity of the system.</span><br /><span style="font-size: 11pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; "></span><br /><span style="font-size: 11pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">Changes must be handled on a case-by-case basis, but the primary mode of operation should follow the agile ideal: a single team with responsibility for a project end-to-end.  This includes contributing to assets it consumes.</span><br /><span style="font-size: 11pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; "></span><br /><span style="font-size: 11pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: bold; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">What if even the initial project is too big?</span><br /><span style="font-size: 11pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">I’ll touch on one final question: what if even the initial scope of a project is beyond what a single team can accomplish?  Find a smaller initial scope, get it working, and grow from there.  Do this even if the initial scope means building placeholders that are discarded in the final result.  The time saved and friction eliminated by creating a single, focused team will outweigh this.  Think of it as scaffolding that eventually gets removed.</span><br /><span style="font-size: 11pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; "></span><br /><span style="font-size: 11pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">In the end, </span><span style="font-size: 11pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">Agile in the Large only works if we make it more like Agile in the Small.</span><span style="font-size: 11pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">  Hopefully this article is a step in that direction.</span></div></span></span></div>]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Beware of the Flying Car]]></title>
    <link href="http://www.toomuchcode.org/blog/2010/10/16/beware-of-the-flying-car/"/>
    <updated>2010-10-16T22:20:51-05:00</updated>
    <id>http://www.toomuchcode.org/blog/2010/10/16/beware-of-the-flying-car</id>
    <content type="html"><![CDATA[<div style="margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; background-color: transparent; font-family: Times; font-size: medium; "><span id="internal-source-marker_0.4220108645968139" style="font-size: 11pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">Every so often we developers are asked to build a flying car. Our users obviously need one to avoid traffic and get to meetings on time. So we set down the path to meet those needs.</span><br /><span style="font-size: 11pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; "></span><br /><span style="font-size: 11pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">The trouble is most of us have no idea how to build a flying car. Even so, this is the project so we better get started! Our first release of the flying car will be small, and carried around on a string. We show good progress to our user&#8217;s needs and gain approval from our superiors. We will simply remove the string in a later release.</span><br /><span style="font-size: 11pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; "></span><br /><span style="font-size: 11pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">Hopefully most of us will recognize a Flying Car Project and take time to understand and address the users’ goals rather than sprinting toward a brick wall.  The Flying Car is a means, not an end in itself &#8211; and there are other, executable means to the desired end.  </span><br /><span style="font-size: 11pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; "></span><br /><span style="font-size: 11pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">Of course, there will always be </span><span style="font-size: 11pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: normal; font-style: italic; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; ">someone</span><span style="font-size: 11pt; font-family: Arial; color: rgb(0, 0, 0); background-color: transparent; font-weight: normal; font-style: normal; text-decoration: none; vertical-align: baseline; white-space: pre-wrap; "> eager to go build that flying car.  If that happens, try to steer them in the right direction.  If all else fails, just don’t be standing underneath it when they cut the string.</span><br /></div>]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[And We're Back]]></title>
    <link href="http://www.toomuchcode.org/blog/2010/10/16/and-were-back/"/>
    <updated>2010-10-16T09:04:13-05:00</updated>
    <id>http://www.toomuchcode.org/blog/2010/10/16/and-were-back</id>
    <content type="html"><![CDATA[After an unbelievably long hiatus, I&#8217;m going to start blogging again.  It&#8217;s funny how becoming a parent makes everything else seem to go away for a while.<div><br /></div><div>I don&#8217;t expect I will ever post at a regular intervals here.  I&#8217;ll post when I feel like I can express something that gets closer to some truth about software &#8211; at least to me.   How often will that happen?  Who knows?</div><div><br /></div><div>The rebirth of this blog will come with a shift in material, at least for the near future.  I&#8217;ve recently become more interested in the social aspect of building software.  How should we organize ourselves to create great software?  How should that change over time?</div><div><br /></div><div>I am and always will be a programmer at heart.  My shift in emphasis simply comes from the realization that our biggest challenges aren&#8217;t technical.  They&#8217;re social.</div>]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The Guru Myth]]></title>
    <link href="http://www.toomuchcode.org/blog/2008/11/15/the-guru-myth/"/>
    <updated>2008-11-15T12:59:04-06:00</updated>
    <id>http://www.toomuchcode.org/blog/2008/11/15/the-guru-myth</id>
    <content type="html"><![CDATA[Anyone who has worked in software long enough has heard questions like this:<br /><br /><div style="text-align: center;"><i>I&#8217;m getting exception XYZ.  Do you know what the problem is?</i><br /></div><i><br /></i>The questioner didn&#8217;t bother to include a stack trace, an error log, or any context leading to the problem.  He or she seems to think you operate on a different plane, that solutions appear to you without analysis based on evidence.  This person thinks you are a guru.<br /><br />We expect such questions from those unfamiliar with software; to them systems can seem almost magical.  What worries me is seeing this in the software community.  Similar questions arise in program design, such as &#8220;I&#8217;m building inventory management.  Should I use optimistic locking?&#8221;  Ironically, the person asking the question is often better equipped to answer it than the question&#8217;s recipient.  The questioner presumably knows the context, knows the requirements, and can read about the advantages and disadvantages of different strategies.  Yet this person expects an intelligent answer without supplying context.  He or she expects magic.<br /><br />It&#8217;s time for the software industry to dispel this guru myth.  &#8220;Gurus&#8221; are human; they apply logic and systematically analyze problems like the rest of us.  Consider the best programmer you&#8217;ve ever met:  At one point he or she knew less about software than you do now.  If that person seems like a guru, it&#8217;s because of years dedicated to learning and refining thought processes.  A &#8220;guru&#8221; is simply a smart person with relentless curiosity.<br /><br />Of course, there remains a huge variance in natural aptitude.  Many hackers out there are smarter, more knowledgeable, and more productive than I may ever be.  Even so, debunking the guru myth has a positive impact.  For instance, when working with someone smarter than me I am sure to do the legwork, to provide enough context so that person can efficiently apply his or her skills.  Removing the guru myth also means removing a perceived barrier to improvement.  Instead of a barrier I see a continuum on which I can advance.<br /><br />Finally, one of software&#8217;s biggest obstacles is smart people who purposefully propagate the guru myth.  This might be done out of ego, or as a strategy to increase one&#8217;s value as perceived by a client or employer.  Ironically this attitude makes a smart person less valuable, since they don&#8217;t contribute to the growth of their peers.  We don&#8217;t need gurus.  We need experts willing to develop other experts in their field.  There is room for all of us.]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Tearing Down the Software Factory]]></title>
    <link href="http://www.toomuchcode.org/blog/2008/03/09/tearing-down-the-software-factory/"/>
    <updated>2008-03-09T15:25:44-05:00</updated>
    <id>http://www.toomuchcode.org/blog/2008/03/09/tearing-down-the-software-factory</id>
    <content type="html"><![CDATA[Tom DeMarco <a title="said it well" href="http://www.amazon.com/Measuring-Managing-Performance-Organizations-Robert/dp/0932633366" id="wp1z">said it well</a>:<br /><blockquote>The idea of a software factory is a joke &#8211; that we can build software by rote &#8211; that&#8217;s ridiculous.  If the work is deterministic, we will do with it what we do with any other big piece of deterministic work.  We&#8217;ll let the computer do the deterministic portion, leaving the person who interacts with the computer &#8211; the other half of the system &#8211; to do the work whose roteness has decreased, not increased.  Every time you automate something, what&#8217;s left of the person&#8217;s work is less deterministic, until eventually, when you automate enough, there&#8217;s no deterministic element left for the person&#8217;s work&#8211;no rote. &#8230; Our work is not deterministic.  It&#8217;s far too inventive.  We&#8217;re knowledge workers, not factory workers.<br /></blockquote>Of course, similar thoughts have been articulated <a title="many" href="http://www.developerdotstar.com/mag/articles/reeves_design_main.html" id="j1bs">many</a> <a title="times" href="http://virtualschool.edu/mon/SoftwareEngineering/BrooksNoSilverBullet.html" id="s7.0">times</a> before, and was a theme of the <a title="previous post" href="http://www.toomuchcode.org/2007/10/design-crisis.html" id="oihe">previous post</a> on this blog.  The idea of a software factory contradicts our best understanding of the essence of software, yet industrial style command-and-control management of software continues.  Why is this?  One problem is we developers haven&#8217;t effectively presented a convincing alternative.  Remove command and control, and to some extent developers must manage themselves.  From <a title="Watts Humphrey" href="http://www.sei.cmu.edu/news-at-sei/columns/watts_new/2007/06/watts-new-2007-06.htm" id="hcuj">Watts Humphrey</a>:<br /><blockquote>Since your manager’s performance depends on your performance, and since the performance of software groups has historically been so poor, managers do not trust software professionals to manage themselves. To overcome this problem, all we have to do is to convince management that we can manage ourselves and then perform that self management so well that management will continue to trust us.<br /></blockquote>The theme of trust and credibility runs throughout Humphrey&#8217;s <a title="written extensively" href="http://www.sei.cmu.edu/news-at-sei/columns/watts_new/watts-new.htm" id="hbo3">extensive writing</a> on this topic.  This is not new, but progress has been slow.  The major obstacle is that managers rightly want concrete, objective data on which to base their decisions.  This conflicts with the black box that software development so often becomes.  We need better transparency.  It is time to open up the black box of software engineering.<br /><br /><b>The black box of software</b><br />Opening the black box means programmers and managers must meet each other halfway.  Managers must create and adapt to a new post-industrial management science, and programmers must produce data useful to that management science.   This does not mean attempting to make programmers into assembly line workers.  To the contrary, it means embracing the creative nature of software, and managing the output as a side effect of development.<br /><br />How do we do this?  Empirically manage everything that can be empirically managed, and complement it with the judgment of your best engineers.  Many pieces of the puzzle already exist.  <a title="Unit testing" href="http://en.wikipedia.org/wiki/Unit_testing" id="lze7">Unit testing</a>, <a title="code coverage reports" href="http://en.wikipedia.org/wiki/Code_coverage" id="rqf8">code coverage reports</a>, <a title="bug tracking" href="http://en.wikipedia.org/wiki/Bug_tracking_system" id="gezm">bug tracking</a>, <a title="static code analysis" href="http://en.wikipedia.org/wiki/Static_code_analysis" id="z03-">static code analysis</a>, dependency management and others provide transparency into the state of a project.  Such data is purely informational, but technically inclined managers can and should use it to ensure a project is on track.  With context, problems like bloated dependencies, poor test coverage, or fixing related bugs many times are all signs of a project going astray.  Modern software organizations must be able to detect and correct problems before they grow.<br /><br />Unfortunately many managers today are not equipped to work with such data.  This must change.  Managers must build their skill sets for the post-industrial world.<br /><br /><b>Trust through transparency<br /></b>Of course tools like code coverage and defect tracking only tell part of the story.  <a title="Code is design" href="http://www.toomuchcode.org/2007/10/design-crisis.html" id="f.tg">Code is design</a>, and no set of tools can define the quality or progress of design.  Therefore we must complement these tools with the best judgment of our best engineers.  But if managers don&#8217;t trust the best engineers, this judgment is wasted.<br /><br />So how do we solve this?  Use transparency into software as a tool for building trust.   Concrete data on the progress and quality of software gives managers greater confidence in engineers, even if the picture is incomplete.  Trust begins to grow.  Engineers should qualify empirical data and use it appropriately as a basis for design decisions.   If we can provide managers a glimpse into software and prove we are making progress, they will be more willing to accept our opinions.<br /><br />Some tension between managers and developers may be inevitable, but we can meet each other halfway.  Our development practices should yield hard data for everything appropriate.  In exchange managers must accept that code is design and trust the judgment of developers.]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[End of software's dark age?]]></title>
    <link href="http://www.toomuchcode.org/blog/2008/01/06/end-of-softwares-dark-age/"/>
    <updated>2008-01-06T21:51:50-06:00</updated>
    <id>http://www.toomuchcode.org/blog/2008/01/06/end-of-softwares-dark-age</id>
    <content type="html"><![CDATA[Software has held more promise and yet met with more failure than any other technology.  Meanwhile the hardware guys have been merrily creating more and more CPU cycles for us to swamp.<br /><br />A lot has been written about why software sucks.  <span style="font-style: italic;"> </span>Fred Brooks famously predicted there would be <a title="no silver-bullet" href="http://inst.eecs.berkeley.edu/%7Emaratb/readings/NoSilverBullet.html">no silver bullet</a>   improvement in software productive over the next ten years.  That was twenty years ago, but there are signs that the dark age of software might be slowly and quietly coming to an end.<br /><br />Brooks was right about the lack of a silver bullet, of course.  But since then we&#8217;ve learned that we&#8217;ve been trying to kill the wrong monster.  Building a program was compared to the reliable timeline and quality of building a bridge or skyscraper, and we were mystified on how to get there.  This is the wrong monster; instead we need to view code as design and adopt our practices to match.  Coding is a creative process with much more in common with design than with any industrial process &#8211; <a href="http://www.developerdotstar.com/mag/articles/reeves_design_main.html" title="Jack Reeves got it right">Jack Reeves got it right</a>.<br /><br />Notice successful development methodologies jibe with viewing code as design.  We unit test because a design isn&#8217;t complete until validated with a simulation.  We work in iterations because a change in one part of the design affects others.  We document in the source code itself because that is the definitive source of design.<br /><br />The code-is-design perspective also predicts many supposed mysteries: huge productivity variance, a high number of defects, and failures of rote process are all expected in unvalidated, untested design.<br /><br /><span style="font-weight: bold;">Mysteries and Problems</span><br />Fortunately we&#8217;ve taken an important step: software development was once a mystery in search of a silver bullet; now it is a problem with real progress.  Noam Chomsky pointed out the first step to understanding the natural world is to turn mysteries into problems.  We&#8217;re seeing the same with software engineering.<br /><br />Given the premise of code being design, here are some steps to take us in the right direction:<br /><br />1. Boil out the remaining accidents.  We can still have race conditions or leak resources in many programming languages.  Newer languages should make these mistakes impossible.  We can also learn from existing languages.  For instance, the messaging model in Erlang prevents many types of timing problems.   Functional languages may eliminate the many types of bugs which arise from side effects.  The essence of a design should not be concerned with timing or unexpected side effects, so whenever possible this should be solved in the language itself.<br /><br />2. Make validation of designs easy.  How about the following requirement for a new programming language:   <br /><br />   <span>It must be straightforward to write a unit test to reproduce any possible bug.</span><br /><br />Since designs must be validated with computer simulation, we must make those simulations easy.  Huge strides have been made with various unit testing frameworks, but there are still shortcomings.  Proofs of correctness are impractical for most systems, but the ability to easily assert a system doesn&#8217;t have a particular bug is the next best thing.  Furthermore, any bug discovered at any time should be added to the test suite to make sure it never occurs again.  This ensures the defect rate of a system trends towards zero.<br /><br />3.  Design and code should merge into a single artifact.  We still need design at a higher level than current programming languages, but this design needs to be an asset rather than a burden that gets out of synch with the code.<br /><br />We are already seeing this: documentation has been merged with source code and tools convert code to UML diagrams and vice versa.  But there is a lot of room for improvement.  Code in object-oriented languages often includes many unessential objects that are just noise from a high-level view.  These should be eliminated from the language, or at least filtered from the high-level design.<br /><br />There are surely many other examples that I&#8217;m overlooking, and functional languages do hold promise.  What&#8217;s important is we now have an idea of why software sucks, and an inkling of what the solution might be.]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[What we can learn from databases]]></title>
    <link href="http://www.toomuchcode.org/blog/2007/12/26/what-we-can-learn-from-databases/"/>
    <updated>2007-12-26T12:19:04-06:00</updated>
    <id>http://www.toomuchcode.org/blog/2007/12/26/what-we-can-learn-from-databases</id>
    <content type="html"><![CDATA[While not perfect, relational databases are among the most successful software ever used.  Their behavior is easily understood even under high concurrency. Sets of changes can be composed with almost no effort, with strong guarantees of consistency.  The question is: would this be true if we built our databases the same way we build applications?<br /><br />Transactions and read consistency would be the first to go.  Users must then cooperatively synchronize on some external monitor; any failure to do so can result in invalid data.  Next, system state and logic become intermixed.  Gone are simple ways to inspect the state of the system, or create a well-defined state space with known transitions.  In short, if databases were written like applications, they become vulnerable to all of the bugs we see in applications.<br /><br />Suppose we turn the question on its head, and ask what characteristics of the database we can apply to the rest of software?  Consider the following advantages:<br /><ul><li>The system itself guarantees a consistent view of data under concurrency, eliminating many types of race conditions</li><li>State changes are composable; updates are committed atomically, ensuring the database is never in an invalid state.<br /></li><li>The state space is understandable.  Because updates are composed to an atomic state change, countless permutations of state are eliminated</li></ul>The key is this: we can confidently inspect, reason about, and change the state space of a database.  The complexity of large models is mitigated by allowing only for valid, composable transitions.  Imagine if we had such guarantees when building software in general.  We could understand the state of an application at any time, and ensure all changes are valid and consistent.  Our system would be much more understandable and predictable.<br /><br />In fact, much language research is focused on this area.  <a title="Software-Transactional Memory" href="http://research.microsoft.com/%7Esimonpj/papers/stm/stm.pdf" id="r1g6">Software Transactional Memory</a> in languages like Haskell is the most visible.  The question is how such progress will reach the mainstream.  History suggests an evolutionary model.  Languages that gain adoption tend to have a good deal in common with an established language, lowering the barrier to entry.  Because of this, I have yet to see a language with the above characteristics that I think will achieve widespread adoption.  Hopefully that will change.<br /><br /><b>Understandable systems today<br /></b>A couple of <a title="recent" href="http://steve-yegge.blogspot.com/2007/12/codes-worst-enemy.html" id="b02u">recent</a> <a title="posts" href="http://www.codinghorror.com/blog/archives/001025.html" id="pqvj">posts</a> point out the burden of large code bases.  I agree, as suggested by the title of this blog, but it&#8217;s easy to confuse a symptom with the problem itself.  So I phrase it differently:  Unmanageable complexity is the enemy.  Code size is often what the enemy smells like.<br /><br />Developers can better manage complexity even without guarantees similar to what a database offers.  Code should have a clear, easily understood state space, preferably applying related changes atomically.  Such systems are easier to reason about and change because developers need not concern themselves with side effects of unrelated code; they can focus on the problem at hand.  For those who haven&#8217;t explored this, I&#8217;m indirectly describing the functional style of programming.  This is the great hope for pure functional programming: it may spread predictability and a simple model to all development.]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The Design Crisis]]></title>
    <link href="http://www.toomuchcode.org/blog/2007/11/04/the-design-crisis/"/>
    <updated>2007-11-04T08:13:43-06:00</updated>
    <id>http://www.toomuchcode.org/blog/2007/11/04/the-design-crisis</id>
    <content type="html"><![CDATA[Imagine waking up tomorrow and learning the construction industry has made the breakthrough of the century.  Millions of cheap, incredibly fast robots can now fabricate materials out of thin air, have a near-zero power cost, and can repair themselves.  And it gets better: given an unambiguous blueprint for a construction project, the robots can build it without human intervention, all at negligible cost.<br /><br />One can imagine the impact to the construction industry, but what would happen upstream?  How would the behavior of architects and designers change if construction costs are negligible?  Today, physical and computer models are built and rigorously tested before investing in construction.  Would we bother if the construction was essentially free?  If a design collapses, no big deal&#8230;just find out what went wrong and have our magical robots build another one.  More implications follow.  With models obsolete, unfinished designs evolve by repeatedly building and improving upon an approximation of the end goal.  A casual observer may have trouble distinguishing an unfinished design from a finished product.<br /><br />Our ability to predict time lines will fade away as well.  Construction costs are more easily calculated than design costs &#8211; we know the approximate cost to install a girder, and how many girders we need.  As predictable tasks shrink toward zero, the less predictable design time grows to dominate the project.  Results are produced more quickly than before, but reliable time lines slip away.<br /><br />Of course, the pressures of a competitive economy still apply.  With construction costs eliminated, a company that can quickly complete a design gains a market edge.  Pressure on getting design done fast becomes the central push of engineering firms.  Inevitably, someone not deeply familiar with the design will see an unvalidated version, see the market advantage of releasing early, and say &#8220;This looks good enough.&#8221;<br /><br />Some life-or-death projects will be more diligent, but in many cases consumers learn to suffer through the incomplete design.  Companies can always send out our magic robots to &#8220;patch&#8221; the broken buildings and vehicles they sell.  All of this points to an amazing, counter-intuitive conclusion: our sole premise was a dramatic reduction in construction costs, and the result is<i> quality got worse.</i><i> </i><br /><b><br />The Design Crisis<br /></b> It shouldn&#8217;t surprise us the above story has played out in software.  If we accept that <a href="http://www.developerdotstar.com/mag/articles/reeves_design_main.html" id="oj-0" title="code is design">code is design</a> &#8211; a creative process rather than a mechanical one &#8211; the software crisis is explained.   Now we have a design crisis:<i> </i>the demand for quality, validated designs far exceeds our capacity to create them.  The pressure to use incomplete design is strong.<br /><br />Fortunately, this model also gives us some clues on how we can get better.  Physical simulations equate to automated testing; software design isn&#8217;t complete until it is validated with a brutal battery of such tests.  To make such tests more effective we are finding ways to rein in the huge state space of large systems.  Improved languages and design practices give us hope.  Most importantly, there is one inescapable fact.  Great designs are produced by great designers dedicating themselves to the mastery of their craft.  Code is no different.]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[von Neumann's Long Farewell]]></title>
    <link href="http://www.toomuchcode.org/blog/2007/06/30/von-neumanns-long-farewell/"/>
    <updated>2007-06-30T13:44:42-05:00</updated>
    <id>http://www.toomuchcode.org/blog/2007/06/30/von-neumanns-long-farewell</id>
    <content type="html"><![CDATA[A big step in solving the software crisis is to accept that programming is not about computers.  Yes, it used to be, and still is for brave souls working on operating systems or compilers.   But in the long list of the world&#8217;s software struggles, compilers rank pretty low.<br /><br />It&#8217;s easy to think programming is about computers because that&#8217;s where we see problems.  Of course, these are only symptoms of human error.  Developers are constantly stretching to express behavior in terms friendly to a computer, making life harder so we can be easier on our machines.  Such problems have been pointed out decades ago by the likes of <a href="http://www.cs.utexas.edu/%7EEWD/transcriptions/EWD03xx/EWD340.html" title="Dijkstra">Dijkstra</a>, <a href="http://www.stanford.edu/class/cs242/readings/backus.pdf" title="Backus [pdf]">Backus [pdf]</a>, and <a href="http://mitpress.mit.edu/sicp/full-text/book/book.html" title="Abelson and Sussman">Abelson and Sussman</a>.  Surely there is a way to describe our systems better than the terms of the von Neumann architecture.<br /><br />For years we were limited by the capabilities of the machines, but this limitation has vanished for most of us.  We&#8217;ve entered a new era, where improving the way we build software is as much a social problem as a technical one.  Fortunately, there are signs of a growing social bedrock that could finally help us.<br /><b><br />The Thirst for Abstraction</b><br />For a long time I didn&#8217;t understand Guy Steele&#8217;s comments on how Java can pull C++ developers about halfway to Lisp.  Surely that fraction must be off; writing code in Java certainly feels a lot closer to C++ than Lisp.  But independent of the Java language, the platform did a major service for the industry: it proved to the masses that we no longer need to express our designs directly in terms of the von Neumann architecture.<br /><br />The abstraction offered by Java-like languages is small but significant.  The conventional wisdom in software has long held that code must be expressed in terms of the machine to achieve passable performance.  This myth is gone.  Nearly every major software company is adopting some form of garbage collected, virtual machine-based language.  We rely on the platform to map our higher-level expressions to efficient machine code.<br /><br />This is a big step because accepting this level of abstraction opens the door to others.  Why should we explicitly state data type information, when it can be inferred at compile or run time?  Why not abandon primitives and arrays for objects and lists, since our platforms can now optimize away unneeded allocation?  Why struggle with keeping track of many small state changes when major operations could change state atomically?  Such abstractions make life easier for us, and previous successes suggest it will work.  The result is a self-perpetuating thirst for abstraction.  Expressing designs so humans can easily reason about and manipulate them is addicting.<br /><br /><b>von Neumann&#8217;s Long Farewell</b><br />For many of us the shift away from the von Neumann architecture is painfully slow.   Unfortunately the best ideas are often slow to be adopted.  People are used to the way they&#8217;ve worked before, or averse to risk.  So our transition toward better software is incremental &#8211; but it is happening.  Mainstream languages are offering higher-level concepts in their latest revisions.  Adding concepts like closures, type inference, and applicative libraries does the software industry a service.  It moves us toward a better way to write code.  Hopefully some day we&#8217;ll realize the low-level complexity we&#8217;ve dealt with isn&#8217;t really necessary and abandon it altogether.]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Why are we so polarized about Java?]]></title>
    <link href="http://www.toomuchcode.org/blog/2007/06/03/why-are-we-so-polarized-about-java/"/>
    <updated>2007-06-03T11:38:05-05:00</updated>
    <id>http://www.toomuchcode.org/blog/2007/06/03/why-are-we-so-polarized-about-java</id>
    <content type="html"><![CDATA[It seems impossible to constructively praise or criticize Java without eliciting strong reactions.  It comes from both sides; some seem to love to hate Java, and parts of the Java community become defensive as a reaction.<br /><br />For example, Paul Buchheit recently <a title="posted some insights" href="http://paulbuchheit.blogspot.com/2007/05/amazingly-bad-apis.html">posted some insights</a> into API design, referring to poor examples that happen to be written in Java.  He immediately states he doesn&#8217;t hate Java.  The post is about APIs, not the language.  Even so, he still had to update his post saying &#8220;It&#8217;s not about Java, really&#8221;, presumably because of some polarized reactions.   This is unfortunate because it distracts us from Paul&#8217;s excellent commentary.<br /><br />I suspect the polarization starts from a trap I have fallen into myself.  Like many involved in language discussions, I use Java professionally and other languages at night, so I run into examples analogous to the one described by Paul Buchheit.  I sometimes get frustrated with poor APIs, and also with the Java language &#8211; either directly or by association with poor APIs.  I wonder, couldn&#8217;t it use powerful constructs I use in other languages, or could the APIs just plain be simpler?  <br /><br />The problem is my frustration may linger when I discuss programming languages, and (knowingly or unknowingly) be reflected in my tone when discussing Java.  The resulting post is more acidic, and less level handed than I would like.  Those who disagree with my arguments are likely to pick up on that tone and may respond in kind.  Before long we&#8217;ve spiraled into isolated camps, and meaningful discussion is hard to achieve.  My <a title="last post" href="http://toomuchcode.blogspot.com/2007/05/why-java-lost-its-mojo-and-what-sun-is.html">last post</a> had signs of this.<br /><br />So, where did I go wrong?  When discussing constructive criticism of Java and its APIs, we need to view Java with some perspective.  We need to remember its history.  So my first point is:<br /><blockquote><div style="text-align: left;"> </div><i>We are critical of Java in a context different from the one in which it was designed.</i></blockquote><i></i>  A key goal for Java was to replace C++, and this goal led to design decisions that are often targets for criticism today.  In 1996 it wasn&#8217;t clear we could create a sufficiently fast language without primitive types and arrays.  It wasn&#8217;t clear how much boilerplate code would be required by anonymous callback classes or checked exceptions.  It wasn&#8217;t clear that since the <i>new</i> syntax exactly specifies implementation, factory patterns would proliferate, and so on.  So my second point:<br /><div style="text-align: left;"><blockquote> <i>Criticisms of Java should not imply any negatives about the designers of Java.  Critics of Java are likely working in a problem space that differs from Java&#8217;s original design goals, or incorporating new knowledge from the past decade.</i></blockquote><i></i></div>  There are certainly some that disagreed with the above decisions in 1996, but it was surely more debatable then, and different decisions may have slowed Java&#8217;s proliferation &#8211; which was opposed to its original design goals.<br /><br />The key is we need to keep this background in mind whenever discussing Java.  We can criticize Java and its APIs without insulting anyone.  When being critical of Java, any frustrations should be tempered by knowing the landscape has changed.  Similarly, apologists should recognize that criticism need not be viewed as an attack; it might be an attempt to make things better.]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Why Java lost its mojo, and what Sun is doing about it]]></title>
    <link href="http://www.toomuchcode.org/blog/2007/06/02/why-java-lost-its-mojo%2C-and-what-sun-is-doing-about-it/"/>
    <updated>2007-06-02T08:36:30-05:00</updated>
    <id>http://www.toomuchcode.org/blog/2007/06/02/why-java-lost-its-mojo,-and-what-sun-is-doing-about-it</id>
    <content type="html"><![CDATA[<span style="font-weight: bold;"></span>It&#8217;s old news to some, and hotly debated by others, but Java has lost its mojo.  The Java community still has growth from large companies, but it hasn&#8217;t been the darling language of hackers for a while (if it ever was).  But don&#8217;t think Sun isn&#8217;t doing anything about it.<br /><br />Java&#8217;s popularity is a function of market position, the perception of one product compared to its competitors.  When it first came out, Java was positioned against C++, to which it compares favorably.  Yes, I miss operator overloading and a handful of other items, but these are outweighed by the fact that Java prevents entire classes of errors made by C++ developers.  All of this was done before, but Sun was able to make it mainstream and practicable.<br /><br />Now the Java vs. C++ battle is effectively over.  Today Java&#8217;s market position is measured against a variety of languages, most frequently C#, Python, and Ruby.  For many of us, Java compares much less favorably to these than to C++.  Proponents of these languages love to show problems solved in a handful of lines, with a Java-based solution including dozens of lines of boilerplate code.  The poor Java developer is then pushed around and has his lunch money stolen.<br /><br />Naturally, much of the Java community wants to do something about this.  So <a title="closures" href="http://www.javac.info/">closures</a> and <a title="type inference" href="http://weblogs.java.net/blog/forax/archive/2006/12/call_me_santa.html">type inference</a> have been proposed for Java 7, and the debate in the Java community begins.  Some say &#8220;Hooray, Python programmers will stop making fun of me!&#8221;  Others object &#8220;Don&#8217;t we already have enough constructs to worry about in this language?&#8221;  Throw in the glacier-like JCP, and we have no idea what the next release of Java will look like.<br /><br /><span style="font-weight: bold;">Can we fix Java?</span><br />I am sympathetic to both arguments.  The language <span style="font-style: italic;">is</span> getting big.  If only we could get rid of artifacts like primitive types and arrays, we could remove clutter and make conceptual room for more advanced concepts.  Even so, I still land firmly in the pro-closure camp.  This is partially for selfish reasons; I got hooked on them while hacking in functional languages at night, and want to use them in my day job.  My company uses Java because it is actually the right choice for us.  No other platform offers that combination of portability, reliability, tooling, and performance.  Too bad it&#8217;s not with a better language.<br /><br />With this in mind, the rumblings of the last few years make sense, and the future is clear.   It&#8217;s not about Java at all, it&#8217;s about the JVM.  And Sun is positioning the JVM to become a light, efficient virtual machine available everywhere.  Consider everything that has happened:<br /><ul><li><a title="JavaFX" href="http://java.sun.com/javafx/">JavaFX</a> has been announced, creating a simple, declarative model to compete with the likes of Flex.</li><li>Sun has committed to releasing an update to Java 6 that will shrink the minimal JRE download to two megabytes.</li><li>Sun hired <a title="Charles Nutter" href="http://headius.blogspot.com/">Charles Nutter</a> to make JRuby a first-class language for the JVM.  The 1.0 release nears.<br /></li><li>Glassifish &#8211; the open-source application server sponsored by Sun &#8211; will run JRuby applications directly in v3, and be pluggable for new hosts.  Java SE and EE need never enter the picture.</li><li>The JVM is now available under the GPL, which should increase availability on Linux.</li><li>The 2007 JavaOne conference included a <a title="Scala" href="http://www.scala-lang.org/">Scala</a> session for the first time</li></ul>What does this tell us?  The JRE is becoming the new POSIX.  And the Java language is becoming less and less relevant.  (Can&#8217;t find where I first saw this idea posted&#8230;please send link if you have it.)<br /><span style="font-weight: bold;"><br /><span style="font-weight: bold;">But what about the mean time?</span></span><br />The reality is Java-the-language will be around for some time to come, at least until a clear successor is established.  Sun and other members of the JCP have an opportunity to define the language&#8217;s legacy.  As Guy Steele famously said, Java &#8220;managed to drag a lot of them [C++ programmers] about halfway to Lisp.&#8221;  Now Java can drag programmers one step closer to Lisp, and set the stage for the next generation of languages.<br /><br />Of course, I&#8217;m referring to closures.  Users of functional languages will attest how working with such constructs changes how you think.  By adding closures to Java, we do more than provide a powerful tool for those of us already familiar with the construct.  We introduce a large community to a better way of solving many problems.  We&#8217;ll see if it sticks, but I can&#8217;t think of a better way to spread a thought model many believe to be superior.<br /><br /><span style="font-weight: bold;">Update:</span>  I actually don&#8217;t think Java sucks.  It meets the early goal as a straightforward replacement for C++ very well.  I do believe we can create a language that is better than Java based on what we&#8217;ve learned over the last decade.]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The Imaginary Concurrency Debate]]></title>
    <link href="http://www.toomuchcode.org/blog/2007/04/08/the-imaginary-concurrency-debate/"/>
    <updated>2007-04-08T16:01:32-05:00</updated>
    <id>http://www.toomuchcode.org/blog/2007/04/08/the-imaginary-concurrency-debate</id>
    <content type="html"><![CDATA[It&#8217;s finally being accepted: the shared memory, critical region model for concurrent programming is broken.   Even good programmers slip up and introduce race conditions, and bad programmers don&#8217;t even understand the semantics.  (You mean I have to lock an object just to <span style="font-style: italic;">read</span> its values?)<br /><br />The question is: how do we fix it?  Two proposals have drawn attention: The Actor/Message model and Software-Transactional Memory (STM).  The former eliminates shared state entirely, using messaging primitives for communication between threads, which may or may not be in the same process or physical machine.  The latter preserves shared memory, but each thread has a consistent view of shared state during an operation and makes updates atomically, much like a database transaction.  We&#8217;ll refer to these as the <a title="Erlang model" href="http://www-128.ibm.com/developerworks/java/library/j-cb04186.html?ca=drs">Erlang model</a> and the <a title="Haskell model (pdf)" href="http://research.microsoft.com/%7Esimonpj/papers/stm/stm.pdf">Haskell model (pdf)</a>, respectively, referring to the programming languages that most visibly use these synchronization techniques.<br /><br />A debate between these models has quietly arisen.  Proponents of the shared-nothing model point out the scalability and simplicity of Erlang.  Proponents of STM point out the composability of guaranteeing updates to two components can be made atomically.  Incredibly, it seems like this entire debate is ill-formed, and can be resolved with some simple generalization.<br /><br />First we realize nearly all non-trivial applications use both a form of messaging and shared resources.  A simple web application accepts messages from clients and shares state in a database.  Therefore, any widely used programming environment must offer first-class support for transacted resources <span style="font-style: italic;">and</span> messaging.<br /><br />Now, suppose we view transacted memory simply as a hidden optimization of a transacted resource.  In Erlang I can send messages to an Erlang process in the same physical address space or on a different machine &#8211; the former is simply a runtime optimization and not the concern of the developer.  STM is just a local optimization of a transacted resource; with abstraction we can also host the resource remotely like a database or distributed cache.<br /><br />In fact, the Erlang and Haskell models are closer than they first appear.  The STM proposal for Haskell has almost nothing to suggest a TVar must be locally hosted.  There are Erlang libraries allowing use of an RDBMS.   Both of these could be implementations of a general &#8220;transacted resource&#8221; API or Monad.  Similar parallels can be made for the messaging model.  Of course the languages have other significant differences, but these concepts are not so far apart.<br /><br />So where does this leave us in the concurrency debate?  I think we can draw some conclusions:<br /><ul><li>Today&#8217;s concurrency primitives can be abandoned, replaced by messaging and transacted resources</li><li>Messaging and shared resources are complementary constructs used in most applications</li><li>Shared memory is to transacted resources what in-process messaging is to general messaging: a hidden optimization</li><li>Applications should use messages, transactions, or an appropriate combination depending on their needs<br /> </li></ul>  Now we need to ask why no widespread language has yet to replace critical region primitives with messaging and transacted memory.  I think this is largely because such languages are hard to design.  Notice how I&#8217;m generalizing STM and transacted databases to the same concept, but they have very different usage patterns in practice.  It will be a challenge to design something this general yet simple enough so people will actually want to use it.  But I&#8217;m an optimist.<br /><br />One final note: both of these models are more easily implemented using a functional programming style.  Something as simple as immutable objects makes both local messaging and transactions much simpler and more efficient.  It&#8217;s funny how good practices pay off in ways we don&#8217;t expect.]]></content>
  </entry>
  
</feed>
